<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Book Pro</title>
    
    <!-- Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@400;600&family=Roboto+Mono:wght@400;600&display=swap');
        body { font-family: 'Sarabun', sans-serif; background-color: #262421; color: #fff; overflow: hidden; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #211f1c; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        
        input[type=range].vertical {
            -webkit-appearance: none; width: 8px; height: 100%;
            background: #403d39; border-radius: 4px; outline: none;
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; cursor: pointer;
        }
        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px;
            background: #fff; border-radius: 50%; border: 2px solid #aaa; cursor: pointer;
        }

        /* Variation Styling */
        .var-block { margin-left: 0px; background: #2a2825; padding: 4px 8px; margin-bottom: 2px; border-left: 3px solid #504c47; font-size: 0.85rem; color: #aaa; font-family: 'Roboto Mono', monospace; white-space: normal; line-height: 1.4; }
        .var-text { cursor: pointer; transition: color 0.2s; }
        .var-text:hover { color: #fff; text-decoration: underline; }
        
        .main-row { display: flex; border-bottom: 1px solid #302e2b; }
        .main-cell { flex: 1; padding: 6px 8px; font-family: 'Roboto Mono', monospace; font-size: 0.95rem; cursor: pointer; display: flex; align-items: center;}
        .main-cell:hover { background-color: #302e2b; }
        .main-num { width: 40px; text-align: center; color: #666; background: #211f1c; padding: 6px 0; font-size: 0.85rem; display: flex; align-items: center; justify-content: center; }
        .active-move { background-color: #b58863 !important; color: white; font-weight: bold; }

        /* Toggle Switch */
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        
        /* Figurine Font Style */
        .figurine { font-family: 'Times New Roman', serif; font-size: 1.1em; margin-right: 1px; }

        /* Animation for Modal */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Icons ---
        const Icon = ({ path, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );
        const Icons = {
            FileText: (p) => <Icon {...p} path={<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></>} />,
            RotateCcw: (p) => <Icon {...p} path={<><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></>} />,
            ChevronLeft: (p) => <Icon {...p} path={<polyline points="15 18 9 12 15 6"/>} />,
            ChevronRight: (p) => <Icon {...p} path={<polyline points="9 18 15 12 9 6"/>} />,
            ChevronsLeft: (p) => <Icon {...p} path={<><polyline points="11 17 6 12 11 7"/><polyline points="18 17 13 12 18 7"/></>} />,
            ChevronsRight: (p) => <Icon {...p} path={<><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></>} />,
            Download: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></>} />,
            Share: (p) => <Icon {...p} path={<><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></>} />,
            Trash: (p) => <Icon {...p} path={<><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>} />,
            MessageSquare: (p) => <Icon {...p} path={<><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></>} />,
            Activity: (p) => <Icon {...p} path={<><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></>} />,
            Save: (p) => <Icon {...p} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>} />,
            Folder: (p) => <Icon {...p} path={<><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></>} />,
            Scissors: (p) => <Icon {...p} path={<><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></>} />,
            Eye: (p) => <Icon {...p} path={<><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>} />,
            EyeOff: (p) => <Icon {...p} path={<><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></>} />,
            Upload: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>} />,
            ExternalLink: (p) => <Icon {...p} path={<><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></>} />,
            Brain: (p) => <Icon {...p} path={<><path d="M12 16v-4"/><path d="M12 8h.01"/><path d="M20.5 10c0-2.5-2-4.5-4.5-4.5a6 6 0 0 0-11.2 3.6c-1.3.5-2.3 1.7-2.3 3.2 0 1.9 1.5 3.5 3.5 3.5 0 2.5 2 4.5 4.5 4.5a6 6 0 0 0 9.2-2.3c1.3.1 2.5-1.1 2.5-2.4 0-1.4-1.2-2.6-2.6-2.6h-.1"/></>} />,
            Navigation: (p) => <Icon {...p} path={<><polygon points="3 11 22 2 13 21 11 13 3 11"/></>} />,
            Keyboard: (p) => <Icon {...p} path={<><rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect><line x1="6" y1="8" x2="6" y2="8"></line><line x1="10" y1="8" x2="10" y2="8"></line><line x1="14" y1="8" x2="14" y2="8"></line><line x1="18" y1="8" x2="18" y2="8"></line><line x1="6" y1="12" x2="6" y2="12"></line><line x1="10" y1="12" x2="10" y2="12"></line><line x1="14" y1="12" x2="14" y2="12"></line><line x1="18" y1="12" x2="18" y2="12"></line><line x1="6" y1="16" x2="6" y2="16"></line><line x1="10" y1="16" x2="16" y2="16"></line></>} />,
            Close: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>} />,
            FileCode: (p) => <Icon {...p} path={<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M9 13v-1h6v1"/></>} />,
            Server: (p) => <Icon {...p} path={<><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></>} />,
            Globe: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></>} />
        };
        const { FileText, RotateCcw, ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight, Download, Share, Trash, MessageSquare, Activity, Save, Folder, Scissors, Eye, EyeOff, Upload, ExternalLink, Brain, ArrowRight, Navigation, Keyboard, Close, FileCode, Server, Globe } = Icons;

        const PIECE_IMAGES = {
            'w': { 'p': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg', 'n': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg', 'q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg' },
            'b': { 'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg', 'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg', 'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg' }
        };

        const loadPieceImages = async () => {
            const images = { w: {}, b: {} };
            const loadImage = (url) => new Promise((res, rej) => {
                const img = new Image(); img.crossOrigin = "Anonymous"; img.src = url; img.onload = () => res(img); img.onerror = rej;
            });
            for (let c of ['w', 'b']) {
                for (let p of ['p', 'n', 'b', 'r', 'q', 'k']) {
                    try {
                        const img = await loadImage(PIECE_IMAGES[c][p]);
                        const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=128;
                        cvs.getContext('2d').drawImage(img,0,0,128,128);
                        images[c][p] = cvs.toDataURL('image/png');
                    } catch(e){}
                }
            }
            return images;
        };

        // --- HASH UTILS ---
        const computeSHA256 = async (str) => {
            const buf = new TextEncoder().encode(str);
            const hashBuf = await crypto.subtle.digest('SHA-256', buf);
            return Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        // Delimiters for embedding data in PDF
        const EMBED_START = "\n###CHESS_DATA_START###\n";
        const EMBED_END = "\n###CHESS_DATA_END###";

        class MoveNode {
            constructor(san, fen, parent = null, moveNumber = 1, turn = 'w') {
                this.id = Math.random().toString(36).substr(2, 9);
                this.san = san;
                this.fen = fen;
                this.parent = parent;
                this.children = [];
                this.moveNumber = moveNumber;
                this.turn = turn;
                this.comment = "";
                this.eval = null; 
                this.aiEval = null; 
            }
        }

        class GameMetadata {
            constructor() {
                this.title = "Chess Game Record";
                this.filename = "Chess";
                this.author = "Chess_Book_pro";
                this.event = "";
                this.date = new Date().toLocaleDateString();
            }
        }

        // --- Chess Utils ---
        const toFigurine = (san) => {
            if (!san) return "";
            return san.replace(/K/g, "♔").replace(/Q/g, "♕").replace(/R/g, "♖").replace(/B/g, "♗").replace(/N/g, "♘");
        };

        const uciToSan = (fen, uci) => {
            if (!uci) return null;
            try {
                const tempGame = new Chess(fen);
                const move = tempGame.move(uci, { sloppy: true });
                return move ? move.san : uci;
            } catch (e) { return uci; }
        };

        const formatPvSequence = (fen, pvString) => {
            if (!pvString) return [];
            const tempGame = new Chess(fen);
            const moves = pvString.split(' ');
            const formatted = [];
            const limit = 10; 
            for (let i = 0; i < Math.min(moves.length, limit); i++) {
                const uci = moves[i];
                try {
                    const moveObj = tempGame.move(uci, { sloppy: true });
                    if (moveObj) {
                        const turnNum = tempGame.turn() === 'b' ? (Math.floor((tempGame.history().length + 1) / 2)) + "." : "";
                        const prefix = (i === 0 && moveObj.color === 'b') ? `${Math.floor((tempGame.history().length + 1) / 2)}... ` : (moveObj.color === 'w' ? `${Math.floor((tempGame.history().length + 1) / 2)}. ` : "");
                        formatted.push({ prefix: prefix, san: toFigurine(moveObj.san) });
                    }
                } catch (e) { break; }
            }
            return formatted;
        };

        const getBoardFromFen = (fen) => {
            const board = [];
            const rows = fen.split(' ')[0].split('/');
            for (let row of rows) {
                const r = [];
                for (let char of row) {
                    if (isNaN(char)) r.push(char); else for (let i = 0; i < parseInt(char); i++) r.push(null);
                }
                board.push(r);
            }
            return board;
        };

        const generateTreePGN = (node) => {
            if (!node || node.san === 'Start') {
                if(node && node.children.length > 0) return generateTreePGN(node.children[0]);
                return "";
            }
            let text = "";
            if (node.turn === 'w') text += `${node.moveNumber}. ${node.san} `;
            else text += `${node.moveNumber}... ${node.san} `;
            if (node.comment) text += `{ ${node.comment} } `;
            if (node.children.length > 0) text += generateTreePGN(node.children[0]);
            for (let i = 1; i < node.children.length; i++) text += `( ${generateTreePGN(node.children[i])} ) `;
            return text;
        };

        const getFullVariationText = (startNode) => {
            let text = ""; let temp = startNode; let first = true;
            while(temp) {
                if (temp.turn === 'w') text += `${temp.moveNumber}. ${temp.san} `;
                else { if(first) text += `${temp.moveNumber}... ${temp.san} `; else text += `${temp.san} `; }
                first = false;
                if(temp.children.length > 0) temp = temp.children[0]; else temp = null;
            }
            return text;
        };

        // Serialize ensures all meta data including AI evals are saved
        const serializeNode = (node) => ({
            san: node.san, fen: node.fen, moveNumber: node.moveNumber, turn: node.turn, 
            comment: node.comment, eval: node.eval, aiEval: node.aiEval, 
            children: node.children.map(serializeNode)
        });
        const deserializeNode = (data, parent = null) => {
            const node = new MoveNode(data.san, data.fen, parent, data.moveNumber, data.turn);
            node.comment = data.comment; node.eval = data.eval; node.aiEval = data.aiEval;
            node.children = data.children.map(c => deserializeNode(c, node));
            return node;
        };

        // --- AI Fetch Functions ---
        // 1. Standard Lichess Fetcher
        const fetchEvalFromLichess = async (fen) => {
            try {
                const response = await fetch(`https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.pvs && data.pvs.length > 0) {
                        let val = 0;
                        if (data.pvs[0].mate) {
                            val = data.pvs[0].mate > 0 ? 100 : -100;
                        } else {
                            val = data.pvs[0].cp / 100;
                        }
                        return { ...data, val: val, source: 'Lichess Cloud' };
                    }
                }
            } catch (e) { console.error("Lichess Fetch Error:", e); }
            return null;
        };

        // 2. Custom Cloudflare Worker Fetcher
        const fetchEvalFromCloudflare = async (fen, url) => {
            if (!url) return null;
            try {
                // Assume standard GET request with 'fen' parameter
                const response = await fetch(`${url}?fen=${encodeURIComponent(fen)}`);
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data) {
                        const bestMoveRaw = data.bestmove || data.bestMove || (data.moves ? data.moves.split(' ')[0] : null);
                        if (!bestMoveRaw) return null;

                        // Calculate normalized value (cp or mate)
                        let val = 0;
                        let mate = data.mate || null;
                        let cp = data.cp || (data.score && !data.mate ? data.score * 100 : 0);
                        
                        // Handle raw score if provided as decimal (e.g., 0.5) instead of centipawns
                        if (data.score && Math.abs(data.score) < 100 && !data.cp) {
                             cp = data.score * 100;
                        }

                        if (mate) {
                            val = mate > 0 ? 100 : -100;
                        } else {
                            val = cp / 100;
                        }

                        const pvStr = data.pv || data.moves || bestMoveRaw;

                        // Mock the Lichess Structure
                        return {
                            pvs: [{
                                moves: pvStr,
                                cp: cp,
                                mate: mate
                            }],
                            depth: data.depth || 0,
                            val: val,
                            source: 'Cloudflare/Custom'
                        };
                    }
                }
            } catch (e) { 
                console.error("Cloudflare Fetch Error:", e); 
                return null;
            }
            return null;
        };

        // --- Metadata Parsing Helper ---
        const parseMetadata = (comment) => {
            const meta = new GameMetadata();
            if (!comment) return meta;
            
            const lines = comment.split('\n');
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.toLowerCase().startsWith('title:')) meta.title = trimmed.substring(6).trim();
                else if (trimmed.toLowerCase().startsWith('file:')) meta.filename = trimmed.substring(5).trim();
                else if (trimmed.toLowerCase().startsWith('filename:')) meta.filename = trimmed.substring(9).trim();
                
                const pgnMatch = trimmed.match(/^\[(\w+)\s+"(.*)"\]$/);
                if (pgnMatch) {
                    const key = pgnMatch[1].toLowerCase();
                    const val = pgnMatch[2];
                    if (key === 'title') meta.title = val;
                    if (key === 'filename' || key === 'file') meta.filename = val;
                    if (key === 'author' || key === 'white' || key === 'black') meta.author = val;
                    if (key === 'event') meta.event = val;
                }
            });
            return meta;
        };

        // --- AI Display Component ---
        const AiDisplayPanel = ({ title, icon: IconComp, enabled, onToggle, data, loading, error, children, color }) => (
            <div className={`rounded-lg border mb-2 transition-all ${enabled ? `border-${color}-500/50 bg-[${color}-900]/10` : 'border-[#403d39] bg-[#302e2b]'}`}>
                <div className="p-3 flex justify-between items-center bg-black/20 rounded-t-lg">
                    <span className={`text-sm font-bold flex items-center gap-2 ${enabled ? `text-${color}-400` : 'text-gray-400'}`}>
                        <IconComp size={16}/> {title}
                    </span>
                    <div className="relative inline-block w-8 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" checked={enabled} onChange={onToggle} className="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label className={`toggle-label block overflow-hidden h-4 rounded-full cursor-pointer ${enabled ? `bg-${color}-500` : 'bg-gray-600'}`}></label>
                    </div>
                </div>
                
                {enabled && (
                    <div className="p-3 border-t border-white/5 space-y-3">
                        {children}
                        
                        {loading ? (
                            <div className="text-center py-4 text-xs text-gray-500 animate-pulse">Analyzing...</div>
                        ) : error ? (
                            <div className="text-center py-2 text-xs text-red-400">{error}</div>
                        ) : data ? (
                            <div className="space-y-2">
                                <div className="flex gap-2">
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Eval</div>
                                        <div className={`text-sm font-bold ${data.val > 0 ? 'text-green-400' : data.val < 0 ? 'text-red-400' : 'text-gray-300'}`}>
                                            {data.pvs[0].mate ? `#${data.pvs[0].mate}` : (data.val).toFixed(2)}
                                        </div>
                                    </div>
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Depth</div>
                                        <div className="text-sm font-bold text-blue-400">{data.depth}</div>
                                    </div>
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Best</div>
                                        <div className="text-sm font-bold text-green-300 figurine font-mono">{data.bestMoveSan}</div>
                                    </div>
                                </div>
                                <div className="bg-black/30 p-2 rounded text-[10px] text-gray-400 font-mono leading-relaxed max-h-16 overflow-y-auto">
                                    {data.formattedPv.map((m, i) => <span key={i} className={i===0?"text-yellow-200":""}>{m.prefix}{m.san} </span>)}
                                </div>
                            </div>
                        ) : (
                             <div className="text-center py-2 text-xs text-gray-600">Waiting for position...</div>
                        )}
                    </div>
                )}
            </div>
        );

        const App = () => {
            const initialFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
            const rootNode = useMemo(() => new MoveNode('Start', initialFen, null, 0, 'b'), []);
            
            const [currentNode, setCurrentNode] = useState(rootNode);
            const [game, setGame] = useState(new Chess());
            const [selectedSquare, setSelectedSquare] = useState(null);
            const [possibleMoves, setPossibleMoves] = useState([]);
            const [movablePieces, setMovablePieces] = useState([]);
            const [orientation, setOrientation] = useState('white');
            const [isGenerating, setIsGenerating] = useState(false);
            const [notification, setNotification] = useState(null);
            const [gameStatus, setGameStatus] = useState(null);
            const [evalValue, setEvalValue] = useState(null);
            const [commentValue, setCommentValue] = useState("");
            const [savedCollections, setSavedCollections] = useState([]);
            const [activeTab, setActiveTab] = useState('notation');
            const [showHighlights, setShowHighlights] = useState(true);
            const [showAiArrow, setShowAiArrow] = useState(true);
            
            // Promotion State
            const [promotionPending, setPromotionPending] = useState(null);

            // Modal States
            const [showShortcuts, setShowShortcuts] = useState(false);
            const [showCollections, setShowCollections] = useState(false);

            // AI States - Dual Engine
            const [lichessEnabled, setLichessEnabled] = useState(false);
            const [customEnabled, setCustomEnabled] = useState(false);
            const [aiAutoEval, setAiAutoEval] = useState(true); // Applies to custom first, then lichess
            
            const [lichessData, setLichessData] = useState(null);
            const [customData, setCustomData] = useState(null);
            
            const [isLichessLoading, setIsLichessLoading] = useState(false);
            const [isCustomLoading, setIsCustomLoading] = useState(false);
            
            const [pdfProgress, setPdfProgress] = useState(0);
            const [cloudflareUrl, setCloudflareUrl] = useState('');

            const lichessTimeoutRef = useRef(null);
            const customTimeoutRef = useRef(null);
            
            // Separate Caches
            const lichessCache = useRef({});
            const customCache = useRef({});

            useEffect(() => {
                const saved = localStorage.getItem('chess_book_collections');
                if (saved) setSavedCollections(JSON.parse(saved));

                // Load Custom Engine Settings
                const savedCfUrl = localStorage.getItem('chess_book_cf_url');
                const savedCustomEnabled = localStorage.getItem('chess_book_custom_enabled');
                const savedLichessEnabled = localStorage.getItem('chess_book_lichess_enabled');
                
                if (savedCfUrl) setCloudflareUrl(savedCfUrl);
                if (savedCustomEnabled) setCustomEnabled(savedCustomEnabled === 'true');
                if (savedLichessEnabled) setLichessEnabled(savedLichessEnabled === 'true');
            }, []);

            // Save settings when changed
            useEffect(() => {
                localStorage.setItem('chess_book_cf_url', cloudflareUrl);
                localStorage.setItem('chess_book_custom_enabled', customEnabled);
                localStorage.setItem('chess_book_lichess_enabled', lichessEnabled);
            }, [cloudflareUrl, customEnabled, lichessEnabled]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    if (promotionPending) return; // Disable keyboard during promotion selection
                    switch(e.key) {
                        case 'ArrowLeft': if (currentNode.parent) setCurrentNode(currentNode.parent); break;
                        case 'ArrowRight': if (currentNode.children.length > 0) setCurrentNode(currentNode.children[0]); break;
                        case 'ArrowUp': setCurrentNode(rootNode); break;
                        case 'ArrowDown': { let temp = currentNode; while(temp.children.length > 0) temp = temp.children[0]; setCurrentNode(temp); break; }
                        case 'Delete': case 'Backspace': deleteCurrentNodeRef.current(); break;
                        case 'f': case 'F': setOrientation(prev => prev === 'white' ? 'black' : 'white'); break;
                        case 's': case 'S': saveCollectionRef.current(); break;
                        case 'a': case 'A': setShowAiArrow(prev => !prev); break;
                        default: break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentNode, rootNode, promotionPending]);

            const deleteCurrentNodeRef = useRef();
            const saveCollectionRef = useRef();

            // --- AI Logic: Lichess ---
            const runLichessEval = useCallback(async (fen) => {
                if (!lichessEnabled) { setLichessData(null); return; }
                if (lichessCache.current[fen]) { setLichessData(lichessCache.current[fen]); return; }
                
                setIsLichessLoading(true); setLichessData(null);
                const data = await fetchEvalFromLichess(fen);
                
                if (data) {
                    let processedData = data;
                    if (data.pvs && data.pvs.length > 0) {
                        const pv = data.pvs[0];
                        const bestMoveUci = pv.moves.split(' ')[0];
                        const bestMoveSan = uciToSan(fen, bestMoveUci);
                        const formattedPv = formatPvSequence(fen, pv.moves);
                        processedData = { ...data, bestMoveSan: toFigurine(bestMoveSan), bestMoveUci: bestMoveUci, formattedPv: formattedPv };
                    }
                    lichessCache.current[fen] = processedData;
                    setLichessData(processedData);
                } else {
                    setLichessData(null); // No data found
                }
                setIsLichessLoading(false);
            }, [lichessEnabled]);

            // --- AI Logic: Custom ---
            const runCustomEval = useCallback(async (fen) => {
                if (!customEnabled || !cloudflareUrl) { setCustomData(null); return; }
                if (customCache.current[fen]) { setCustomData(customCache.current[fen]); return; }
                
                setIsCustomLoading(true); setCustomData(null);
                const data = await fetchEvalFromCloudflare(fen, cloudflareUrl);
                
                if (data) {
                    let processedData = data;
                    if (data.pvs && data.pvs.length > 0) {
                        const pv = data.pvs[0];
                        const bestMoveUci = pv.moves.split(' ')[0];
                        const bestMoveSan = uciToSan(fen, bestMoveUci);
                        const formattedPv = formatPvSequence(fen, pv.moves);
                        processedData = { ...data, bestMoveSan: toFigurine(bestMoveSan), bestMoveUci: bestMoveUci, formattedPv: formattedPv };
                    }
                    customCache.current[fen] = processedData;
                    setCustomData(processedData);
                } else {
                    // Don't clear immediately on error, maybe keep old or show error
                    setCustomData(null); 
                }
                setIsCustomLoading(false);
            }, [customEnabled, cloudflareUrl]);

            // --- Trigger AI ---
            useEffect(() => {
                if (lichessTimeoutRef.current) clearTimeout(lichessTimeoutRef.current);
                if (customTimeoutRef.current) clearTimeout(customTimeoutRef.current);
                
                // Reset UI if disabled
                if(!lichessEnabled) setLichessData(null);
                if(!customEnabled) setCustomData(null);

                // Debounce Calls
                if (lichessEnabled) lichessTimeoutRef.current = setTimeout(() => runLichessEval(currentNode.fen), 1000);
                if (customEnabled) customTimeoutRef.current = setTimeout(() => runCustomEval(currentNode.fen), 1000); // Priority engine
                
                return () => {
                    clearTimeout(lichessTimeoutRef.current);
                    clearTimeout(customTimeoutRef.current);
                };
            }, [currentNode, lichessEnabled, customEnabled, runLichessEval, runCustomEval]);

            // --- Auto-Eval Priority Logic ---
            useEffect(() => {
                if (!aiAutoEval || currentNode.eval !== null) return;
                
                // Priority 1: Custom Data
                if (customData) {
                    currentNode.aiEval = customData.val;
                    return; 
                }
                
                // Priority 2: Lichess Data (only if Custom is disabled or no data yet)
                if (lichessData && (!customEnabled || !cloudflareUrl)) {
                    currentNode.aiEval = lichessData.val;
                }
            }, [customData, lichessData, aiAutoEval, currentNode, customEnabled, cloudflareUrl]);


            useEffect(() => {
                const newGame = new Chess();
                const moves = []; let temp = currentNode; while(temp.parent) { moves.push(temp.san); temp = temp.parent; } moves.reverse();
                try { moves.forEach(m => newGame.move(m)); } catch(e) { newGame.load(currentNode.fen); }
                setGame(newGame);
                let status = null;
                const manualLink = "https://arbiters.fide.com/wp-content/uploads/Publications/Manual/Arbiters_Manual_2025.pdf";
                if (newGame.in_checkmate()) status = { title: `Checkmate! ${newGame.turn()==='w'?'Black':'White'} Wins`, sub: 'รุกฆาต', rule: 'Article 5.1.1', link: manualLink };
                else if (newGame.in_stalemate()) status = { title: 'Draw by Stalemate', sub: 'เสมอ (อับ)', rule: 'Article 5.2.1', link: manualLink };
                else if (newGame.insufficient_material()) status = { title: 'Draw - Insufficient Material', sub: 'เสมอ (หมากไม่พอ)', rule: 'Article 5.2.2', link: manualLink };
                else if (newGame.in_threefold_repetition()) status = { title: 'Draw - Threefold Repetition', sub: 'เสมอ (ตาเดินซ้ำ)', rule: 'Article 9.2', link: manualLink };
                else if (newGame.in_draw()) status = { title: 'Draw - 50-Move Rule', sub: 'เสมอ (กฎ 50 ตา)', rule: 'Article 9.3', link: manualLink };
                else if (newGame.in_check()) status = { title: 'Check!', sub: 'รุก!', rule: null };
                setGameStatus(status); setSelectedSquare(null); setPossibleMoves([]); setEvalValue(currentNode.eval); setCommentValue(currentNode.comment || "");
            }, [currentNode]);

            useEffect(() => {
                if (showHighlights && game) setMovablePieces([...new Set(game.moves({ verbose: true }).map(m => m.from))]);
                else setMovablePieces([]);
            }, [game, showHighlights]);

            const updateNodeData = (field, value) => {
                currentNode[field] = value;
                if(field === 'eval') setEvalValue(value);
                if(field === 'comment') setCommentValue(value);
            };

            // Use Custom Data for Display Eval if available, else Lichess
            const effectiveEval = evalValue !== null ? evalValue : (customData ? customData.val : (lichessData ? lichessData.val : 0.0));
            const isUsingAiEval = evalValue === null && (customData || lichessData);
            const showNotification = (msg) => { setNotification(msg); setTimeout(() => setNotification(null), 3000); };

            const executeMove = (from, to, promotion = 'q') => {
                try {
                    const tmp = new Chess();
                    const historyMoves = []; let ptr = currentNode; while(ptr.parent) { historyMoves.unshift(ptr.san); ptr = ptr.parent; }
                    historyMoves.forEach(m => tmp.move(m));
                    const move = tmp.move({ from: from, to: to, promotion: promotion });
                    if (move) {
                        const existing = currentNode.children.find(child => child.san === move.san);
                        if (existing) setCurrentNode(existing);
                        else {
                            const num = game.turn() === 'w' ? currentNode.moveNumber + 1 : currentNode.moveNumber;
                            const newNode = new MoveNode(move.san, tmp.fen(), currentNode, num, game.turn());
                            currentNode.children.push(newNode); setCurrentNode(newNode);
                        }
                        new Audio(move.captured ? 'https://images.chesscomfiles.com/chess-themes/sounds/_common/capture.mp3' : 'https://images.chesscomfiles.com/chess-themes/sounds/_common/move-self.mp3').play().catch(()=>{});
                    }
                } catch(e) {}
                setSelectedSquare(null); 
                setPossibleMoves([]);
            };

            const handleSquareClick = (row, col) => {
                if (promotionPending) return; // Block clicks if promotion pending

                const r = orientation === 'white' ? row : 7 - row;
                const c = orientation === 'white' ? col : 7 - col;
                const sq = String.fromCharCode(97 + c) + (8 - r);
                if (selectedSquare === sq) { setSelectedSquare(null); setPossibleMoves([]); return; }
                if (selectedSquare) {
                    // Check for promotion FIRST
                    const verboseMoves = game.moves({ verbose: true });
                    const isPromotion = verboseMoves.some(m => m.from === selectedSquare && m.to === sq && m.promotion);
                    
                    if (isPromotion) {
                        setPromotionPending({ from: selectedSquare, to: sq });
                        return;
                    }

                    // Normal move execution
                    const p = game.get(selectedSquare);
                    // Just try to move - if it's invalid executeMove will just fail silently or we can check logic
                    // Actually cleaner to check if 'sq' is in possibleMoves
                    if (possibleMoves.includes(sq)) {
                        executeMove(selectedSquare, sq);
                        return;
                    }
                }
                const p = game.get(sq);
                if (p && p.color === game.turn()) { setSelectedSquare(sq); if(showHighlights) setPossibleMoves(game.moves({ square: sq, verbose: true }).map(m => m.to)); } 
                else { setSelectedSquare(null); setPossibleMoves([]); }
            };

            const handlePromotionSelect = (piece) => {
                if (promotionPending) {
                    executeMove(promotionPending.from, promotionPending.to, piece);
                    setPromotionPending(null);
                }
            };

            const deleteCurrentNode = () => { if (!currentNode.parent) return; if (confirm(`Delete ${currentNode.san}?`)) { const p = currentNode.parent; p.children = p.children.filter(c => c.id !== currentNode.id); setCurrentNode(p); }};
            deleteCurrentNodeRef.current = deleteCurrentNode;

            const saveCollection = () => { 
                let name = prompt("Enter Name:"); 
                if (!name) return; 
                let newName = name; let counter = 1;
                while (savedCollections.some(c => c.name === newName)) { newName = `${name} (${counter})`; counter++; }
                const updated = [...savedCollections, { id: Date.now(), name: newName, date: new Date().toLocaleDateString(), data: serializeNode(rootNode) }]; 
                setSavedCollections(updated); 
                localStorage.setItem('chess_book_collections', JSON.stringify(updated)); 
                showNotification(`Saved as "${newName}"`); 
            };
            saveCollectionRef.current = saveCollection;

            const loadCollection = (col) => { 
                if (confirm(`Load "${col.name}"?`)) { 
                    const newRoot = deserializeNode(col.data); rootNode.children = newRoot.children; 
                    const fix = (n, p) => { n.parent = p; n.children.forEach(c => fix(c, n)); }; fix(rootNode, null); 
                    setCurrentNode(rootNode); setActiveTab('notation'); setShowCollections(false);
                }
            };
            const deleteCollection = (id) => { if(confirm("Delete?")) { const updated = savedCollections.filter(c => c.id !== id); setSavedCollections(updated); localStorage.setItem('chess_book_collections', JSON.stringify(updated)); }};
            
            const importFile = (e) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const content = evt.target.result;
                    try {
                        if (content.includes("###CHESS_DATA_START###")) {
                            const parts = content.split("###CHESS_DATA_START###");
                            const rawJson = parts[1].split("###CHESS_DATA_END###")[0];
                            const parsed = JSON.parse(rawJson);
                            if (parsed.data) {
                                const dataToLoad = Array.isArray(parsed.data) ? parsed.data : [{ id: Date.now(), name: `Imported PDF ${new Date().toLocaleTimeString()}`, date: new Date().toLocaleDateString(), data: parsed.data }];
                                const merged = [...savedCollections, ...dataToLoad];
                                setSavedCollections(merged); localStorage.setItem('chess_book_collections', JSON.stringify(merged));
                                showNotification("Data extracted from PDF!");
                            }
                        } else {
                            const imported = JSON.parse(content);
                            if (Array.isArray(imported)) {
                                const merged = [...savedCollections, ...imported]; setSavedCollections(merged); localStorage.setItem('chess_book_collections', JSON.stringify(merged)); showNotification("Collections Imported!");
                            } else throw new Error("Invalid format");
                        }
                    } catch (err) { console.error(err); alert("Invalid File or No Embedded Data found."); }
                };
                reader.readAsText(file, "ISO-8859-1");
            };

            const exportCollections = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedCollections));
                const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr); downloadAnchorNode.setAttribute("download", "chess_collections.json");
                document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove(); showNotification("Collections Exported!");
            };

            const copyPGN = () => { navigator.clipboard.writeText(generateTreePGN(rootNode)).then(()=>showNotification("PGN Copied")); };
            
            const processNodesRecursively = async (node, updateProgress) => {
                if (node.san !== 'Start' && node.eval === null && (!node.aiEval && node.aiEval !== 0)) {
                    if (lichessCache.current[node.fen]) { node.aiEval = lichessCache.current[node.fen].val; } 
                    else {
                        const data = await fetchEvalFromLichess(node.fen);
                        if (data) { node.aiEval = data.val; lichessCache.current[node.fen] = data; }
                        await new Promise(r => setTimeout(r, 2100));
                    }
                }
                updateProgress();
                for (const child of node.children) await processNodesRecursively(child, updateProgress);
            };

            const countNodes = (node) => { let count = 1; for (const child of node.children) count += countNodes(child); return count; };

            const generatePDF = async () => {
                const meta = parseMetadata(rootNode.comment);
                
                if (confirm("Use AI to fill missing evaluations?")) {
                    setIsGenerating(true); setPdfProgress(0);
                    const totalNodes = countNodes(rootNode); let processed = 0;
                    const updateProgress = () => { processed++; setPdfProgress(Math.round((processed / totalNodes) * 100)); };
                    await processNodesRecursively(rootNode, updateProgress);
                }
                setIsGenerating(true); showNotification("Generating Smart PDF...");
                const pdfImgs = await loadPieceImages();
                const { jsPDF } = window.jspdf; const doc = new jsPDF();
                
                doc.setProperties({ title: meta.title, author: meta.author, subject: "Chess Book Pro Smart Doc" });
                doc.setFont("helvetica", "bold"); doc.setFontSize(16); doc.text(meta.title, 105, 15, { align: "center" });
                
                const line = []; let temp = currentNode; while(temp.parent) { line.unshift(temp); temp = temp.parent; } 
                let future = currentNode; while(future.children.length > 0) { future = future.children[0]; line.push(future); }
                let x=25, y=25, col=0, row=0; const boxW=58, boardS=48, boxH=66;
                
                const drawBoard = (fen, label, node) => {
                    const board = getBoardFromFen(fen); const px = x + (boxW-boardS)/2;
                    doc.setFontSize(10); doc.setTextColor(0); doc.text(label, px+boardS/2, y+4, {align:"center"});
                    const by = y+6; doc.setLineWidth(0.05); doc.setDrawColor(0); const sq = boardS/8;
                    for(let r=0;r<8;r++){for(let c=0;c<8;c++){
                        if((r+c)%2===1){ doc.setFillColor(240); doc.rect(px+c*sq, by+r*sq, sq, sq, 'F'); }
                        doc.rect(px+c*sq, by+r*sq, sq, sq);
                        const p=board[r][c];
                        if(p){ const im=pdfImgs[p===p.toUpperCase()?'w':'b'][p.toLowerCase()]; if(im) doc.addImage(im, 'PNG', px+c*sq+0.5, by+r*sq+0.5, sq-1, sq-1); }
                    }}
                    const barY=by+boardS+1; doc.setDrawColor(150); doc.rect(px, barY, boardS, 2.5);
                    const useEval = node.eval !== null ? node.eval : (node.aiEval !== undefined ? node.aiEval : 0.0);
                    const val = Math.max(-5, Math.min(5, useEval)); 
                    const cw = px+(boardS/2); const fw = (Math.abs(val)/5)*(boardS/2);
                    doc.setFillColor(100); if(val>0) doc.rect(cw, barY, fw, 2.5, 'F'); else doc.rect(cw-fw, barY, fw, 2.5, 'F');
                    doc.setDrawColor(0); doc.line(cw, barY, cw, barY+2.5);
                    doc.setFontSize(8); doc.text(`${val>0?'+':''}${Number(val).toFixed(2)}`, px+boardS, barY+6.5, {align:"right"});
                    
                    const isRoot = node.san === 'Start';
                    const commText = isRoot ? "" : (node.comment || "");
                    const comm = doc.splitTextToSize(commText, boardS-10); doc.text(comm.length>2?comm.slice(0,2):comm, px, barY+6.5);

                    if (node.parent) {
                        try {
                            const tmpChess = new Chess(node.parent.fen);
                            const moveObj = tmpChess.move(node.san, { sloppy: true });
                            if (moveObj) {
                                const fromCol = moveObj.from.charCodeAt(0) - 97; const fromRow = 8 - parseInt(moveObj.from[1]); 
                                const toCol = moveObj.to.charCodeAt(0) - 97; const toRow = 8 - parseInt(moveObj.to[1]);
                                const x1 = px + fromCol * sq + sq/2; const y1 = by + fromRow * sq + sq/2;
                                const x2 = px + toCol * sq + sq/2; const y2 = by + toRow * sq + sq/2;
                                doc.setDrawColor(64, 64, 64); doc.setLineWidth(0.25); doc.line(x1, y1, x2, y2);
                                doc.setFillColor(64, 64, 64); doc.circle(x1, y1, 0.35, 'F'); 
                                const angle = Math.atan2(y2 - y1, x2 - x1); const arrowSize = 1.3; 
                                const x3 = x2 - arrowSize * Math.cos(angle - Math.PI / 6); const y3 = y2 - arrowSize * Math.sin(angle - Math.PI / 6);
                                const x4 = x2 - arrowSize * Math.cos(angle + Math.PI / 6); const y4 = y2 - arrowSize * Math.sin(angle + Math.PI / 6);
                                doc.triangle(x2, y2, x3, y3, x4, y4, 'F');
                            }
                        } catch(e) {}
                    }
                };

                drawBoard(initialFen, "Start", rootNode); x+=boxW; col++;
                line.forEach((n,i)=>{ const lbl = n.turn==='w'?`${n.moveNumber}. ${n.san}`:`${n.moveNumber}... ${n.san}`; drawBoard(n.fen, lbl, n); x+=boxW; col++; if(col>=3){ col=0; x=25; y+=boxH; row++; if(row>=4 && i<line.length-1){doc.addPage(); y=25; row=0;} } });
                
                const serializedData = serializeNode(rootNode);
                const jsonStr = JSON.stringify(serializedData);
                const hash = await computeSHA256(jsonStr);
                const payload = { hash: hash, data: serializedData };
                const payloadStr = JSON.stringify(payload);
                const pdfBlob = doc.output('blob');
                const finalBlob = new Blob([pdfBlob, EMBED_START, payloadStr, EMBED_END], { type: 'application/pdf' });
                
                const filename = meta.filename.endsWith('.pdf') ? meta.filename : `${meta.filename}.pdf`;
                const url = URL.createObjectURL(finalBlob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                
                setIsGenerating(false); setPdfProgress(0);
            };

            // Use Custom Best Move if available, else Lichess
            const activeBestMoveUci = customData?.bestMoveUci || lichessData?.bestMoveUci;

            const renderAiArrow = () => {
                if (!showAiArrow || !activeBestMoveUci) return null;
                
                const uci = activeBestMoveUci;
                const from = uci.substring(0, 2);
                const to = uci.substring(2, 4);

                const fromFile = from.charCodeAt(0) - 97; 
                const fromRank = parseInt(from[1]) - 1;
                const toFile = to.charCodeAt(0) - 97; 
                const toRank = parseInt(to[1]) - 1;

                let x1, y1, x2, y2;
                if (orientation === 'white') { 
                    x1 = fromFile; y1 = 7 - fromRank; 
                    x2 = toFile; y2 = 7 - toRank; 
                } else { 
                    x1 = 7 - fromFile; y1 = fromRank; 
                    x2 = 7 - toFile; y2 = toRank; 
                }
                
                const toPct = (v) => v * 12.5 + 6.25;
                const arrowColor = customData ? "#a855f7" : "#3b82f6"; // Purple for Custom, Blue for Lichess

                return (
                    <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-20" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs>
                            <marker id="arrowhead-ai" markerWidth="3" markerHeight="3" refX="2" refY="1.5" orient="auto">
                                <polygon points="0 0, 3 1.5, 0 3" fill={arrowColor} opacity="0.9"/>
                            </marker>
                        </defs>
                        <line 
                            x1={toPct(x1)} y1={toPct(y1)} 
                            x2={toPct(x2)} y2={toPct(y2)} 
                            stroke={arrowColor} 
                            strokeWidth="3" 
                            opacity="0.9" 
                            strokeLinecap="round" 
                            markerEnd="url(#arrowhead-ai)"
                        />
                        <circle cx={toPct(x1)} cy={toPct(y1)} r="1.5" fill={arrowColor} opacity="0.9" />
                    </svg>
                );
            };

            const renderBoard = () => {
                const b = getBoardFromFen(currentNode.fen);
                const sqs = [];
                for(let r=0;r<8;r++){ for(let c=0;c<8;c++){
                    const ar=orientation==='white'?r:7-r, ac=orientation==='white'?c:7-c;
                    const s=String.fromCharCode(97+ac)+(8-ar); const isLight=(ar+ac)%2===0; const p=b[ar][ac];
                    const isSel=selectedSquare===s; const isPoss=possibleMoves.includes(s); const isMov=movablePieces.includes(s);
                    sqs.push(<div key={`${r}-${c}`} onClick={()=>handleSquareClick(ar,ac)} className={`w-full h-full flex justify-center items-center relative cursor-pointer ${isLight?'bg-[#ebecd0]':'bg-[#739552]'} ${isSel?'!bg-[#f7f769]':''}`}>
                        {ac===(orientation==='white'?0:7) && <span className={`absolute top-0.5 left-0.5 text-[10px] font-bold ${isLight?'text-[#739552]':'text-[#ebecd0]'}`}>{8-ar}</span>}
                        {ar===(orientation==='white'?7:0) && <span className={`absolute bottom-0 right-1 text-[10px] font-bold ${isLight?'text-[#739552]':'text-[#ebecd0]'}`}>{String.fromCharCode(97+ac)}</span>}
                        {isMov && !isSel && <div className="absolute w-full h-full border-[3px] border-blue-400/70 rounded-lg z-0"></div>}
                        {isPoss && !p && <div className="w-[30%] h-[30%] rounded-full bg-[rgba(0,0,0,0.2)] z-10"></div>}
                        {isPoss && p && <div className="absolute w-full h-full border-[6px] border-[rgba(0,0,0,0.2)] rounded-full z-10"></div>}
                        {p && <img src={PIECE_IMAGES[p===p.toUpperCase()?'w':'b'][p.toLowerCase()]} className="w-[90%] h-[90%] z-10 relative select-none"/>}
                    </div>);
                }} 
                return <>{sqs}{renderAiArrow()}</>;
            };

            const activeLine = useMemo(() => {
                const line = []; let temp = currentNode; while(temp.parent) { line.unshift(temp); temp = temp.parent; }
                let future = currentNode; while(future.children.length > 0) { future = future.children[0]; line.push(future); }
                const pairs = []; let i = 0;
                while(i < line.length) {
                    const node = line[i];
                    const siblings = node.parent ? node.parent.children.filter(c => c.id !== node.id) : [];
                    if (node.turn === 'w') {
                        const pair = { num: node.moveNumber, white: node, whiteVars: siblings, black: null, blackVars: [] };
                        if (i+1 < line.length && line[i+1].turn === 'b') {
                            pair.black = line[i+1]; pair.blackVars = line[i+1].parent.children.filter(c => c.id !== line[i+1].id); i++;
                        }
                        pairs.push(pair);
                    } else { pairs.push({ num: node.moveNumber, white: null, whiteVars: [], black: node, blackVars: siblings }); }
                    i++;
                }
                return pairs;
            }, [currentNode]);

            // Promotion Modal Component
            const PromotionModal = () => {
                if (!promotionPending) return null;
                const turn = game.turn();
                const pieces = ['q', 'r', 'b', 'n'];
                
                return (
                    <div className="absolute inset-0 z-40 flex items-center justify-center bg-black/40 backdrop-blur-sm animate-fade-in" onClick={() => setPromotionPending(null)}>
                        <div className="bg-[#262421] p-4 rounded-xl border border-[#403d39] shadow-2xl transform scale-100 flex gap-2" onClick={e=>e.stopPropagation()}>
                           {pieces.map(p => (
                               <button key={p} onClick={() => handlePromotionSelect(p)} className="w-16 h-16 bg-[#302e2b] hover:bg-[#403d39] rounded-lg flex items-center justify-center border border-[#403d39] hover:border-green-500 transition-all">
                                   <img src={PIECE_IMAGES[turn][p]} className="w-12 h-12"/>
                               </button>
                           ))}
                        </div>
                    </div>
                );
            };

            return (
                <div className="flex w-screen h-screen bg-[#262421]">
                    {/* Shortcuts Modal */}
                    {showShortcuts && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={()=>setShowShortcuts(false)}>
                            <div className="bg-[#302e2b] p-6 rounded-xl border border-[#403d39] w-[400px] shadow-2xl" onClick={e=>e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b border-[#403d39] pb-2">
                                    <h3 className="text-lg font-bold text-green-500 flex items-center gap-2"><Keyboard size={20}/> Keyboard Shortcuts</h3>
                                    <button onClick={()=>setShowShortcuts(false)} className="text-gray-400 hover:text-white"><Close size={20}/></button>
                                </div>
                                <div className="space-y-3 text-sm text-gray-300">
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">←</span> / <span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">→</span></span> <span>Prev / Next Move</span></div>
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">↑</span> / <span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">↓</span></span> <span>Start / End Game</span></div>
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">Del</span></span> <span>Delete Move</span></div>
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">F</span></span> <span>Flip Board</span></div>
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">S</span></span> <span>Save Collection</span></div>
                                    <div className="flex justify-between"><span className="flex items-center gap-2"><span className="bg-[#403d39] px-2 py-0.5 rounded text-xs">A</span></span> <span>Toggle AI Arrow</span></div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Collections Modal - POPUP SYSTEM */}
                    {showCollections && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm" onClick={()=>setShowCollections(false)}>
                            <div className="bg-[#211f1c] p-0 rounded-xl border border-[#403d39] w-[500px] shadow-2xl flex flex-col max-h-[80vh]" onClick={e=>e.stopPropagation()}>
                                <div className="p-4 border-b border-[#302e2b] flex justify-between items-center bg-[#2a2825] rounded-t-xl">
                                    <h3 className="text-lg font-bold text-gray-200 flex items-center gap-2"><Folder size={18}/> Manage Collections</h3>
                                    <button onClick={()=>setShowCollections(false)} className="text-gray-400 hover:text-white"><Close size={20}/></button>
                                </div>
                                <div className="p-4 flex gap-2 border-b border-[#302e2b] bg-[#302e2b]">
                                    <button onClick={saveCollection} className="flex-1 py-2 bg-blue-600 hover:bg-blue-500 rounded text-sm text-white font-bold flex items-center justify-center gap-1 shadow"><Save size={14}/> Save</button>
                                    <button onClick={exportCollections} className="flex-1 py-2 bg-[#403d39] hover:bg-[#504c47] rounded text-sm text-gray-200 font-bold flex items-center justify-center gap-1"><Download size={14}/> Export JSON</button>
                                    <label className="flex-1 py-2 bg-[#403d39] hover:bg-[#504c47] rounded text-sm text-gray-200 font-bold flex items-center justify-center gap-1 cursor-pointer">
                                        <Upload size={14}/> Import PDF/JSON
                                        <input type="file" accept=".json,.pdf" className="hidden" onChange={importFile} />
                                    </label>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2 bg-[#211f1c]">
                                    {savedCollections.length === 0 && <div className="text-center text-gray-500 py-10">No saved collections found.</div>}
                                    {savedCollections.map(col => (
                                        <div key={col.id} className="bg-[#302e2b] p-3 rounded border border-[#403d39] flex justify-between items-center hover:border-green-500/30 transition">
                                            <div className="flex-1 min-w-0 mr-4">
                                                <div className="text-sm font-bold text-gray-200 truncate">{col.name}</div>
                                                <div className="text-[10px] text-gray-500">{col.date}</div>
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={()=>loadCollection(col)} className="px-3 py-1 bg-green-700 hover:bg-green-600 text-white text-xs rounded font-bold">Load</button>
                                                <button onClick={()=>deleteCollection(col.id)} className="p-1.5 text-red-400 hover:bg-red-900/20 rounded"><Trash size={14}/></button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* LEFT PANEL */}
                    <div className="w-[300px] bg-[#211f1c] border-r border-[#302e2b] flex flex-col p-4 gap-4 overflow-y-auto z-20 shadow-xl">
                        <div className="flex items-center justify-between mb-2">
                            <div className="flex items-center gap-2 text-green-500 font-bold text-xl"><span>♟ Chess Book Pro</span></div>
                            <button onClick={()=>setShowShortcuts(true)} className="p-1.5 bg-[#302e2b] rounded text-gray-400 hover:text-white border border-[#403d39]" title="Keyboard Shortcuts"><Keyboard size={16}/></button>
                        </div>
                        
                        {/* Board Controls */}
                        <div className="bg-[#302e2b] p-3 rounded-lg flex flex-col gap-2">
                            <div className="flex justify-between gap-1">
                                <button onClick={()=>setCurrentNode(rootNode)} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronsLeft size={18}/></button>
                                <button onClick={()=>{if(currentNode.parent)setCurrentNode(currentNode.parent)}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronLeft size={18}/></button>
                                <button onClick={()=>{if(currentNode.children.length)setCurrentNode(currentNode.children[0])}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronRight size={18}/></button>
                                <button onClick={()=>{let t=currentNode;while(t.children.length)t=t.children[0];setCurrentNode(t)}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronsRight size={18}/></button>
                            </div>
                            <div className="flex justify-between gap-1 mt-1">
                                <button onClick={()=>setOrientation(o=>o==='white'?'black':'white')} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><RotateCcw size={18}/></button>
                                <button onClick={()=>setShowHighlights(!showHighlights)} className={`flex-1 p-2 rounded hover:bg-[#504c47] ${showHighlights?'bg-green-600/50 text-green-200':'bg-[#403d39] text-gray-400'}`}>{showHighlights?<Eye size={18}/>:<EyeOff size={18}/>}</button>
                                <button onClick={()=>setShowAiArrow(!showAiArrow)} className={`flex-1 p-2 rounded hover:bg-[#504c47] ${showAiArrow?'bg-blue-600/50 text-blue-200':'bg-[#403d39] text-gray-400'}`} title="Toggle AI Arrow"><Navigation size={18}/></button>
                                <button onClick={deleteCurrentNode} className="flex-1 p-2 bg-[#403d39] text-red-400 rounded hover:bg-[#504c47]"><Scissors size={18}/></button>
                            </div>
                        </div>

                        {/* Eval and Comment */}
                        <div className="bg-[#302e2b] p-3 rounded-lg flex gap-3 h-[240px]">
                            <div className="w-12 flex flex-col items-center gap-2 h-full relative">
                                <span className="text-[10px] text-gray-400">EVAL</span>
                                <div className="relative w-full">
                                    <input type="number" step="0.1" 
                                        value={evalValue !== null ? evalValue : ''} 
                                        placeholder={isUsingAiEval ? "AI" : ""}
                                        onChange={(e)=>updateNodeData('eval', e.target.value === '' ? null : parseFloat(e.target.value))} 
                                        className={`w-full bg-[#211f1c] text-center text-xs rounded border border-[#403d39] py-1 ${isUsingAiEval ? 'text-purple-400 border-purple-500/50' : ''}`}
                                    />
                                    {evalValue !== null && (
                                        <button 
                                            onClick={() => updateNodeData('eval', null)}
                                            className="absolute -right-5 top-0.5 bg-[#403d39] text-[8px] text-gray-300 px-1 rounded hover:bg-gray-600"
                                            title="Reset to AI (Auto)"
                                        >
                                            AI
                                        </button>
                                    )}
                                </div>
                                <div className="flex-1 w-full flex justify-center py-1"><input type="range" min="-5" max="5" step="0.1" value={evalValue !== null ? evalValue : 0} onChange={(e)=>updateNodeData('eval',parseFloat(e.target.value))} className="vertical"/></div>
                                <span className={`text-xs font-mono font-bold ${effectiveEval>0?'text-green-400':effectiveEval<0?'text-red-400':'text-gray-400'}`}>
                                    {effectiveEval>0?'+':''}{Number(effectiveEval).toFixed(1)}
                                </span>
                            </div>
                            <div className="flex-1 flex flex-col gap-2">
                                <div className="text-[10px] text-gray-400 flex items-center gap-1">
                                    <MessageSquare size={12}/> 
                                    {currentNode.san === 'Start' ? "METADATA (Title, File, etc.)" : "COMMENT"}
                                </div>
                                <textarea 
                                    value={commentValue} 
                                    onChange={(e)=>updateNodeData('comment',e.target.value)} 
                                    placeholder={currentNode.san === 'Start' ? "Title: My Game\nFile: my_game_v1\n[Event \"Tournament\"]" : "Notes..."} 
                                    className="w-full h-full bg-[#211f1c] border border-[#403d39] rounded p-2 text-sm text-gray-200 resize-none outline-none focus:border-green-500"
                                />
                            </div>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex gap-2">
                            <button onClick={copyPGN} className="flex-1 py-2 bg-[#302e2b] rounded text-sm font-bold text-gray-300 flex justify-center gap-2 hover:bg-[#403d39]"><Share size={16}/> PGN</button>
                            <button onClick={generatePDF} className="flex-1 py-2 bg-green-600 rounded text-sm font-bold text-white flex justify-center gap-2 shadow hover:bg-green-500"><Download size={16}/> Smart PDF</button>
                        </div>
                        
                        {/* Collection Button */}
                        <button onClick={()=>setShowCollections(true)} className="w-full py-2 bg-[#403d39] rounded text-sm font-bold text-blue-300 flex justify-center gap-2 border border-blue-500/30 hover:bg-[#504c47] hover:border-blue-500">
                            <Folder size={16}/> Collections & Cloud Saves
                        </button>
                        
                        {/* Progress Bar for Batch AI */}
                        {pdfProgress > 0 && (
                            <div className="w-full bg-gray-700 rounded-full h-2.5 mt-2">
                                <div className="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style={{ width: `${pdfProgress}%` }}></div>
                                <div className="text-[10px] text-center text-gray-400 mt-1">AI Processing: {pdfProgress}%</div>
                            </div>
                        )}
                    </div>

                    <div className="flex-1 flex justify-center items-center bg-[#302e2b] p-4 relative">
                        {gameStatus && (
                            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-xl shadow-2xl z-30 bg-gray-800/95 text-white border border-gray-600 backdrop-blur-sm text-center">
                                <div className="font-bold text-lg mb-1 text-green-400">{gameStatus.title}</div>
                                {gameStatus.sub && <div className="text-sm text-gray-300 mb-1">{gameStatus.sub}</div>}
                                {gameStatus.rule && (
                                    <div className="text-xs text-gray-400 flex items-center justify-center gap-2 mt-1">
                                        <span className="font-mono bg-gray-700 px-1.5 py-0.5 rounded border border-gray-600">{gameStatus.rule}</span>
                                        <a href={gameStatus.link} target="_blank" rel="noreferrer" className="text-blue-400 hover:text-blue-300 underline flex items-center gap-1">
                                            FIDE Manual <ExternalLink size={10}/>
                                        </a>
                                    </div>
                                )}
                            </div>
                        )}
                        <div className="w-full h-full max-w-[90vh] max-h-[90vh] aspect-square shadow-2xl border-[8px] border-[#211f1c] grid grid-cols-8 grid-rows-8 relative">
                            {renderBoard()}
                            <PromotionModal />
                        </div>
                    </div>

                    {/* RIGHT PANEL: Notation and AI */}
                    <div className="w-[300px] bg-[#211f1c] border-l border-[#302e2b] flex flex-col relative">
                        <div className="flex border-b border-[#302e2b]">
                            <button onClick={()=>setActiveTab('notation')} className={`flex-1 p-3 text-xs font-bold ${activeTab==='notation'?'text-green-500 border-b-2 border-green-500':'text-gray-400 hover:bg-[#302e2b]'}`}>Notation</button>
                            <button onClick={()=>setActiveTab('ai')} className={`flex-1 p-3 text-xs font-bold ${activeTab==='ai'?'text-purple-500 border-b-2 border-purple-500':'text-gray-400 hover:bg-[#302e2b]'}`}>AI Analysis</button>
                        </div>

                        <div className="flex-1 overflow-y-auto">
                            {activeTab === 'notation' && (
                                <div>{activeLine.map((pair, i) => (
                                    <div key={i}>
                                        <div className="main-row">
                                            <div className="main-num">{pair.num}.</div>
                                            {pair.white ? <div className={`main-cell ${pair.white.id===currentNode.id?'active-move':'text-gray-300'}`} onClick={()=>setCurrentNode(pair.white)}>{pair.white.san}</div> : <div className="main-cell text-gray-600">...</div>}
                                            {pair.black ? <div className={`main-cell ${pair.black.id===currentNode.id?'active-move':'text-gray-300'}`} onClick={()=>setCurrentNode(pair.black)}>{pair.black.san}</div> : <div className="main-cell"></div>}
                                        </div>
                                        {pair.whiteVars.map(v=><div key={v.id} className="var-block"><span className="var-text" onClick={()=>setCurrentNode(v)}>({getFullVariationText(v)})</span></div>)}
                                        {pair.blackVars.map(v=><div key={v.id} className="var-block"><span className="var-text" onClick={()=>setCurrentNode(v)}>({getFullVariationText(v)})</span></div>)}
                                    </div>
                                ))}</div>
                            )}

                            {activeTab === 'ai' && (
                                <div className="p-4 flex flex-col h-full gap-4">
                                    {/* AI Settings - Header */}
                                    <div className="flex justify-between items-center mb-2">
                                        <span className="text-sm font-bold text-gray-200 flex items-center gap-2"><Brain size={16}/> Engines</span>
                                        <div className="flex items-center gap-2">
                                            <span className="text-[10px] text-gray-400">Auto-Apply</span>
                                            <div className="relative inline-block w-6 align-middle select-none transition duration-200 ease-in">
                                                <input type="checkbox" checked={aiAutoEval} onChange={()=>setAiAutoEval(!aiAutoEval)} className="toggle-checkbox absolute block w-3 h-3 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                                <label className={`toggle-label block overflow-hidden h-3 rounded-full cursor-pointer ${aiAutoEval ? 'bg-green-500' : 'bg-gray-600'}`}></label>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Panel 1: Lichess */}
                                    <AiDisplayPanel 
                                        title="Lichess Cloud" 
                                        icon={Globe}
                                        enabled={lichessEnabled}
                                        onToggle={()=>setLichessEnabled(!lichessEnabled)}
                                        data={lichessData}
                                        loading={isLichessLoading}
                                        color="blue"
                                    />

                                    {/* Panel 2: Custom */}
                                    <AiDisplayPanel 
                                        title="Custom Engine" 
                                        icon={Server}
                                        enabled={customEnabled}
                                        onToggle={()=>setCustomEnabled(!customEnabled)}
                                        data={customData}
                                        loading={isCustomLoading}
                                        error={customEnabled && !cloudflareUrl ? "Enter Worker URL below" : null}
                                        color="purple"
                                    >
                                        <div className="mb-2">
                                            <label className="text-[10px] text-gray-400 block mb-1">Worker URL (Private Stockfish API)</label>
                                            <input 
                                                type="text" 
                                                value={cloudflareUrl} 
                                                onChange={(e)=>setCloudflareUrl(e.target.value)}
                                                placeholder="https://my-worker.workers.dev"
                                                className="w-full bg-black/40 text-xs p-2 rounded border border-purple-500/30 text-purple-200 focus:border-purple-500 outline-none font-mono"
                                            />
                                        </div>
                                    </AiDisplayPanel>

                                    {!lichessEnabled && !customEnabled && (
                                        <div className="text-center text-gray-500 text-xs mt-4">
                                            Enable an engine above to start analysis.
                                        </div>
                                    )}

                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>