<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Book Pro (Max Depth)</title>
    
    <!-- Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600&family=Roboto+Mono:wght@400;600&display=swap');
        body { font-family: 'Sarabun', sans-serif; background-color: #262421; color: #fff; overflow: hidden; }
        
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: #211f1c; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 2px; }
        
        input[type=range].vertical {
            -webkit-appearance: none; width: 8px; height: 100%;
            background: #403d39; border-radius: 4px; outline: none;
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; cursor: pointer;
        }
        input[type=range].vertical::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px;
            background: #fff; border-radius: 50%; border: 2px solid #aaa; cursor: pointer;
        }

        .var-block { margin-left: 0px; background: #2a2825; padding: 4px 8px; margin-bottom: 2px; border-left: 3px solid #504c47; font-size: 0.85rem; color: #aaa; font-family: 'Roboto Mono', monospace; white-space: normal; line-height: 1.4; }
        .var-text { cursor: pointer; transition: color 0.2s; }
        .var-text:hover { color: #fff; text-decoration: underline; }
        
        .main-row { display: flex; border-bottom: 1px solid #302e2b; }
        .main-cell { flex: 1; padding: 6px 8px; font-family: 'Roboto Mono', monospace; font-size: 0.95rem; cursor: pointer; display: flex; align-items: center;}
        .main-cell:hover { background-color: #302e2b; }
        .main-num { width: 40px; text-align: center; color: #666; background: #211f1c; padding: 6px 0; font-size: 0.85rem; display: flex; align-items: center; justify-content: center; }
        .active-move { background-color: #b58863 !important; color: white; font-weight: bold; }

        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        
        .figurine { font-family: 'Times New Roman', serif; font-size: 1.1em; margin-right: 1px; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.2s ease-out; }
        .spinner { border: 2px solid rgba(255,255,255,0.1); width: 16px; height: 16px; border-radius: 50%; border-left-color: #4ade80; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile specific fixes */
        .mobile-tab-active { color: #4ade80; border-bottom: 2px solid #4ade80; }
        .mobile-tab-inactive { color: #9ca3af; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        const Icon = ({ path, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );
        const Icons = {
            FileText: (p) => <Icon {...p} path={<><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></>} />,
            RotateCcw: (p) => <Icon {...p} path={<><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></>} />,
            ChevronLeft: (p) => <Icon {...p} path={<polyline points="15 18 9 12 15 6"/>} />,
            ChevronRight: (p) => <Icon {...p} path={<polyline points="9 18 15 12 9 6"/>} />,
            ChevronsLeft: (p) => <Icon {...p} path={<><polyline points="11 17 6 12 11 7"/><polyline points="18 17 13 12 18 7"/></>} />,
            ChevronsRight: (p) => <Icon {...p} path={<><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></>} />,
            Download: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></>} />,
            Share: (p) => <Icon {...p} path={<><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></>} />,
            Trash: (p) => <Icon {...p} path={<><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></>} />,
            MessageSquare: (p) => <Icon {...p} path={<><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></>} />,
            Save: (p) => <Icon {...p} path={<><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></>} />,
            Folder: (p) => <Icon {...p} path={<><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></>} />,
            Scissors: (p) => <Icon {...p} path={<><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" y1="4" x2="8.12" y2="15.88"/><line x1="14.47" y1="14.48" x2="20" y2="20"/><line x1="8.12" y1="8.12" x2="12" y2="12"/></>} />,
            Eye: (p) => <Icon {...p} path={<><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></>} />,
            EyeOff: (p) => <Icon {...p} path={<><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></>} />,
            Upload: (p) => <Icon {...p} path={<><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></>} />,
            ExternalLink: (p) => <Icon {...p} path={<><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></>} />,
            Brain: (p) => <Icon {...p} path={<><path d="M12 16v-4"/><path d="M12 8h.01"/><path d="M20.5 10c0-2.5-2-4.5-4.5-4.5a6 6 0 0 0-11.2 3.6c-1.3.5-2.3 1.7-2.3 3.2 0 1.9 1.5 3.5 3.5 3.5 0 2.5 2 4.5 4.5 4.5a6 6 0 0 0 9.2-2.3c1.3.1 2.5-1.1 2.5-2.4 0-1.4-1.2-2.6-2.6-2.6h-.1"/></>} />,
            Navigation: (p) => <Icon {...p} path={<><polygon points="3 11 22 2 13 21 11 13 3 11"/></>} />,
            Keyboard: (p) => <Icon {...p} path={<><rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect><line x1="6" y1="8" x2="6" y2="8"></line><line x1="10" y1="8" x2="10" y2="8"></line><line x1="14" y1="8" x2="14" y2="8"></line><line x1="18" y1="8" x2="18" y2="8"></line><line x1="6" y1="12" x2="6" y2="12"></line><line x1="10" y1="12" x2="10" y2="12"></line><line x1="14" y1="12" x2="14" y2="12"></line><line x1="18" y1="12" x2="18" y2="12"></line><line x1="6" y1="16" x2="6" y2="16"></line><line x1="10" y1="16" x2="16" y2="16"></line></>} />,
            Close: (p) => <Icon {...p} path={<><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></>} />,
            Server: (p) => <Icon {...p} path={<><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></>} />,
            Globe: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></>} />,
            Cpu: (p) => <Icon {...p} path={<><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></>} />,
            Wrench: (p) => <Icon {...p} path={<><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></>} />
        };
        const { FileText, RotateCcw, ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight, Download, Share, Trash, MessageSquare, Save, Folder, Scissors, Eye, EyeOff, Upload, ExternalLink, Brain, Navigation, Keyboard, Close, Server, Globe, Cpu, Wrench } = Icons;

        const PIECE_IMAGES = {
            'w': { 'p': 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg', 'n': 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg', 'q': 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg' },
            'b': { 'p': 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg', 'n': 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg', 'b': 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg', 'r': 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg', 'q': 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg', 'k': 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg' }
        };

        const loadPieceImages = async () => {
            const images = { w: {}, b: {} };
            const loadImage = (url) => new Promise((res, rej) => {
                const img = new Image(); img.crossOrigin = "Anonymous"; img.src = url; img.onload = () => res(img); img.onerror = rej;
            });
            for (let c of ['w', 'b']) {
                for (let p of ['p', 'n', 'b', 'r', 'q', 'k']) {
                    try {
                        const img = await loadImage(PIECE_IMAGES[c][p]);
                        const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=128;
                        cvs.getContext('2d').drawImage(img,0,0,128,128);
                        images[c][p] = cvs.toDataURL('image/png');
                    } catch(e){}
                }
            }
            return images;
        };

        const computeSHA256 = async (str) => {
            const buf = new TextEncoder().encode(str);
            const hashBuf = await crypto.subtle.digest('SHA-256', buf);
            return Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
        };

        const EMBED_START = "\n###CHESS_DATA_START###\n";
        const EMBED_END = "\n###CHESS_DATA_END###";

        class MoveNode {
            constructor(san, fen, parent = null, moveNumber = 1, turn = 'w') {
                this.id = Math.random().toString(36).substr(2, 9);
                this.san = san;
                this.fen = fen;
                this.parent = parent;
                this.children = [];
                this.moveNumber = moveNumber;
                this.turn = turn;
                this.comment = "";
                this.eval = null; 
                this.aiEval = null; 
                this.aiDepth = 0; // Added to track depth confidence
            }
        }

        class GameMetadata {
            constructor() {
                this.title = "Chess Game Record";
                this.filename = "Chess";
                this.author = "Chess_Book_pro";
                this.event = "";
                this.date = new Date().toLocaleDateString();
            }
        }

        const toFigurine = (san) => {
            if (!san) return "";
            return san.replace(/K/g, "♔").replace(/Q/g, "♕").replace(/R/g, "♖").replace(/B/g, "♗").replace(/N/g, "♘");
        };

        const uciToSan = (fen, uci) => {
            if (!uci) return null;
            try {
                const tempGame = new Chess(fen);
                const from = uci.substring(0, 2);
                const to = uci.substring(2, 4);
                const promotion = uci.substring(4, 5) || undefined;
                const move = tempGame.move({ from, to, promotion });
                return move ? move.san : uci;
            } catch (e) { return uci; }
        };

        const formatPvSequence = (fen, pvString) => {
            if (!pvString) return [];
            const tempGame = new Chess(fen);
            const moves = pvString.split(' ').filter(m => m.trim().length > 0);
            const formatted = [];
            const limit = 8; 
            for (let i = 0; i < Math.min(moves.length, limit); i++) {
                const uci = moves[i];
                try {
                    const from = uci.substring(0, 2);
                    const to = uci.substring(2, 4);
                    const promotion = uci.substring(4, 5) || undefined;
                    const moveObj = tempGame.move({ from, to, promotion });
                    
                    if (moveObj) {
                        const moveNum = Math.floor((tempGame.history().length - 1) / 2) + 1;
                        const prefix = moveObj.color === 'w' ? `${moveNum}.` : (i === 0 ? `${moveNum}...` : "");
                        formatted.push({ prefix: prefix, san: toFigurine(moveObj.san) });
                    }
                } catch (e) { break; }
            }
            return formatted;
        };

        const getBoardFromFen = (fen) => {
            const board = [];
            const rows = fen.split(' ')[0].split('/');
            for (let row of rows) {
                const r = [];
                for (let char of row) {
                    if (isNaN(char)) r.push(char); else for (let i = 0; i < parseInt(char); i++) r.push(null);
                }
                board.push(r);
            }
            return board;
        };

        const generateTreePGN = (node) => {
            if (!node || node.san === 'Start') {
                if(node && node.children.length > 0) return generateTreePGN(node.children[0]);
                return "";
            }
            let text = "";
            if (node.turn === 'w') text += `${node.moveNumber}. ${node.san} `;
            else text += `${node.moveNumber}... ${node.san} `;
            if (node.comment) text += `{ ${node.comment} } `;
            if (node.children.length > 0) text += generateTreePGN(node.children[0]);
            for (let i = 1; i < node.children.length; i++) text += `( ${generateTreePGN(node.children[i])} ) `;
            return text;
        };

        const getFullVariationText = (startNode) => {
            let text = ""; let temp = startNode; let first = true;
            while(temp) {
                if (temp.turn === 'w') text += `${temp.moveNumber}. ${temp.san} `;
                else { if(first) text += `${temp.moveNumber}... ${temp.san} `; else text += `${temp.san} `; }
                first = false;
                if(temp.children.length > 0) temp = temp.children[0]; else temp = null;
            }
            return text;
        };

        const serializeNode = (node) => ({
            san: node.san, fen: node.fen, moveNumber: node.moveNumber, turn: node.turn, 
            comment: node.comment, eval: node.eval, aiEval: node.aiEval, aiDepth: node.aiDepth,
            children: node.children.map(serializeNode)
        });
        const deserializeNode = (data, parent = null) => {
            const node = new MoveNode(data.san, data.fen, parent, data.moveNumber, data.turn);
            node.comment = data.comment; node.eval = data.eval; node.aiEval = data.aiEval; 
            node.aiDepth = data.aiDepth || 0;
            node.children = data.children.map(c => deserializeNode(c, node));
            return node;
        };

        const fetchEvalFromLichess = async (fen) => {
            try {
                const response = await fetch(`https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.pvs && data.pvs.length > 0) {
                        let val = 0;
                        if (data.pvs[0].mate) { val = data.pvs[0].mate > 0 ? 100 : -100; } 
                        else { val = data.pvs[0].cp / 100; }
                        return { ...data, val: val, source: 'Lichess Cloud' };
                    }
                }
            } catch (e) { }
            return null;
        };

        const parseMetadata = (comment) => {
            const meta = new GameMetadata();
            if (!comment) return meta;
            const lines = comment.split('\n');
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.toLowerCase().startsWith('title:')) meta.title = trimmed.substring(6).trim();
                else if (trimmed.toLowerCase().startsWith('file:')) meta.filename = trimmed.substring(5).trim();
                else if (trimmed.toLowerCase().startsWith('filename:')) meta.filename = trimmed.substring(9).trim();
                const pgnMatch = trimmed.match(/^\[(\w+)\s+"(.*)"\]$/);
                if (pgnMatch) {
                    const key = pgnMatch[1].toLowerCase();
                    const val = pgnMatch[2];
                    if (key === 'title') meta.title = val;
                    if (key === 'filename' || key === 'file') meta.filename = val;
                    if (key === 'author' || key === 'white' || key === 'black') meta.author = val;
                    if (key === 'event') meta.event = val;
                }
            });
            return meta;
        };

        const AiDisplayPanel = ({ title, icon: IconComp, enabled, onToggle, data, loading, error, children, color, subTitle }) => (
            <div className={`rounded-lg border mb-2 transition-all ${enabled ? `border-${color}-500/50 bg-[${color}-900]/10` : 'border-[#403d39] bg-[#302e2b]'}`}>
                <div className="p-3 flex justify-between items-center bg-black/20 rounded-t-lg">
                    <div className="flex flex-col">
                        <span className={`text-sm font-bold flex items-center gap-2 ${enabled ? `text-${color}-400` : 'text-gray-400'}`}>
                            {loading ? <div className="spinner"></div> : <IconComp size={16}/>} {title}
                        </span>
                        {subTitle && <span className="text-[10px] text-gray-500 ml-6">{subTitle}</span>}
                    </div>
                    <div className="relative inline-block w-8 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" checked={enabled} onChange={onToggle} className="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label className={`toggle-label block overflow-hidden h-4 rounded-full cursor-pointer ${enabled ? `bg-${color}-500` : 'bg-gray-600'}`}></label>
                    </div>
                </div>
                {enabled && (
                    <div className="p-3 border-t border-white/5 space-y-3">
                        {children}
                        {loading ? (
                            <div className="text-center py-4 text-xs text-gray-500 animate-pulse">Analyzing...</div>
                        ) : error ? (
                            <div className="text-center py-2 text-xs text-red-400">{error}</div>
                        ) : data ? (
                            <div className="space-y-2">
                                <div className="flex gap-2">
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Score</div>
                                        <div className={`text-sm font-bold ${data.val > 0 ? 'text-green-400' : data.val < 0 ? 'text-red-400' : 'text-gray-300'}`}>
                                            {data.mate ? `#${data.mate}` : (data.val).toFixed(2)}
                                        </div>
                                    </div>
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Depth</div>
                                        <div className="text-sm font-bold text-blue-400">{data.depth}</div>
                                    </div>
                                    <div className="bg-black/30 p-2 rounded flex-1 text-center">
                                        <div className="text-[9px] text-gray-500 uppercase">Best</div>
                                        <div className="text-sm font-bold text-green-300 figurine font-mono">{data.bestMoveSan}</div>
                                    </div>
                                </div>
                                <div className="bg-black/30 p-2 rounded text-[10px] text-gray-400 font-mono leading-relaxed max-h-16 overflow-y-auto">
                                    {data.formattedPv.map((m, i) => <span key={i} className={i===0?"text-yellow-200":""}>{m.prefix} {m.san} </span>)}
                                </div>
                            </div>
                        ) : (
                             <div className="text-center py-2 text-xs text-gray-600">Waiting for position...</div>
                        )}
                    </div>
                )}
            </div>
        );

        const App = () => {
            const initialFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
            const rootNode = useMemo(() => new MoveNode('Start', initialFen, null, 0, 'b'), []);
            
            const [currentNode, setCurrentNode] = useState(rootNode);
            const [game, setGame] = useState(new Chess());
            const [selectedSquare, setSelectedSquare] = useState(null);
            const [possibleMoves, setPossibleMoves] = useState([]);
            const [movablePieces, setMovablePieces] = useState([]);
            const [orientation, setOrientation] = useState('white');
            const [notification, setNotification] = useState(null);
            const [gameStatus, setGameStatus] = useState(null);
            const [evalValue, setEvalValue] = useState(null);
            const [commentValue, setCommentValue] = useState("");
            const [savedCollections, setSavedCollections] = useState([]);
            const [activeTab, setActiveTab] = useState('notation');
            const [showHighlights, setShowHighlights] = useState(true);
            const [showAiArrow, setShowAiArrow] = useState(true);
            const [promotionPending, setPromotionPending] = useState(null);
            const [showShortcuts, setShowShortcuts] = useState(false);
            const [showCollections, setShowCollections] = useState(false);
            const [isGenerating, setIsGenerating] = useState(false);
            const [mobileTab, setMobileTab] = useState('tools');
            
            // AI States
            const [lichessEnabled, setLichessEnabled] = useState(false);
            const [stockfishEnabled, setStockfishEnabled] = useState(false);
            const [aiAutoEval, setAiAutoEval] = useState(true);
            const [lichessData, setLichessData] = useState(null);
            const [stockfishData, setStockfishData] = useState(null);
            const [isLichessLoading, setIsLichessLoading] = useState(false);
            const [aiDepth, setAiDepth] = useState(20); // Default Depth
            
            const lichessTimeoutRef = useRef(null);
            const lichessCache = useRef({});
            const stockfishWorker = useRef(null);
            const stockfishUrl = "https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.0/stockfish.js"; 

            // --- HELPER: GET BEST DATA (MAX DEPTH PRIORITY) ---
            const getBestEngineData = useCallback(() => {
                const sfDepth = stockfishData?.depth || 0;
                const liDepth = lichessData?.depth || 0;
                
                // Priority: Depth > 0
                if (sfDepth === 0 && liDepth === 0) return null;
                
                // If Local is deeper or equal, trust local
                if (sfDepth >= liDepth) return stockfishData;
                
                // Else trust cloud
                return lichessData;
            }, [stockfishData, lichessData]);

            useEffect(() => {
                const saved = localStorage.getItem('chess_book_collections');
                if (saved) setSavedCollections(JSON.parse(saved));
                const savedSf = localStorage.getItem('chess_book_stockfish_enabled');
                const savedLi = localStorage.getItem('chess_book_lichess_enabled');
                if (savedSf) setStockfishEnabled(savedSf === 'true');
                if (savedLi) setLichessEnabled(savedLi === 'true');
            }, []);

            useEffect(() => {
                localStorage.setItem('chess_book_stockfish_enabled', stockfishEnabled);
                localStorage.setItem('chess_book_lichess_enabled', lichessEnabled);
            }, [stockfishEnabled, lichessEnabled]);

            // --- LOCAL STOCKFISH ---
            useEffect(() => {
                if (stockfishEnabled && !stockfishWorker.current) {
                    fetch(stockfishUrl).then(r => r.text()).then(code => {
                        const blob = new Blob([code], { type: 'application/javascript' });
                        const worker = new Worker(URL.createObjectURL(blob));
                        worker.onmessage = (e) => {
                            const line = e.data;
                            if (line.startsWith('info') && line.includes('depth') && line.includes('score')) {
                                const depthMatch = line.match(/depth (\d+)/);
                                const scoreMatch = line.match(/score (cp|mate) ([-\d]+)/);
                                const pvMatch = line.match(/ pv (.+)/);
                                if (depthMatch && scoreMatch && pvMatch) {
                                    const depth = parseInt(depthMatch[1]);
                                    const type = scoreMatch[1];
                                    const rawScore = parseInt(scoreMatch[2]);
                                    const pv = pvMatch[1];
                                    if (depth >= 1 || type === 'mate') {
                                        let val = 0; let mate = null; const turnMult = game.turn() === 'w' ? 1 : -1;
                                        if (type === 'mate') { mate = rawScore; val = rawScore > 0 ? 100 : -100; if (game.turn() === 'b') val = -val; } 
                                        else { val = (rawScore * turnMult) / 100; }
                                        const formattedPv = formatPvSequence(game.fen(), pv);
                                        const bestMoveUci = pv.split(' ')[0];
                                        const bestMoveSan = uciToSan(game.fen(), bestMoveUci);
                                        setStockfishData({ val, mate, depth, bestMoveSan: toFigurine(bestMoveSan), bestMoveUci, formattedPv });
                                    }
                                }
                            }
                        };
                        worker.postMessage('uci');
                        worker.postMessage('setoption name Hash value 64');
                        worker.postMessage('setoption name Threads value 4');
                        worker.postMessage('isready');
                        stockfishWorker.current = worker;
                        worker.postMessage(`position fen ${currentNode.fen}`);
                        worker.postMessage(`go depth ${aiDepth}`);
                    });
                } else if (!stockfishEnabled && stockfishWorker.current) {
                    stockfishWorker.current.terminate(); stockfishWorker.current = null; setStockfishData(null);
                }
            }, [stockfishEnabled]);

            useEffect(() => {
                if (stockfishEnabled && stockfishWorker.current) {
                    stockfishWorker.current.postMessage('stop');
                    stockfishWorker.current.postMessage(`position fen ${currentNode.fen}`);
                    stockfishWorker.current.postMessage(`go depth ${aiDepth}`);
                }
            }, [currentNode, stockfishEnabled, aiDepth]);

            // --- Lichess ---
            const runLichessEval = useCallback(async (fen) => {
                if (!lichessEnabled) { setLichessData(null); return; }
                if (lichessCache.current[fen]) { setLichessData(lichessCache.current[fen]); return; }
                setIsLichessLoading(true); setLichessData(null);
                const data = await fetchEvalFromLichess(fen);
                if (data) {
                    let processedData = data;
                    if (data.pvs && data.pvs.length > 0) {
                        const pv = data.pvs[0]; const bestMoveUci = pv.moves.split(' ')[0]; const bestMoveSan = uciToSan(fen, bestMoveUci);
                        const formattedPv = formatPvSequence(fen, pv.moves);
                        processedData = { ...data, bestMoveSan: toFigurine(bestMoveSan), bestMoveUci: bestMoveUci, formattedPv: formattedPv };
                    }
                    lichessCache.current[fen] = processedData; setLichessData(processedData);
                }
                setIsLichessLoading(false);
            }, [lichessEnabled]);

            useEffect(() => {
                if (lichessTimeoutRef.current) clearTimeout(lichessTimeoutRef.current);
                if(!lichessEnabled) setLichessData(null);
                if (lichessEnabled) lichessTimeoutRef.current = setTimeout(() => runLichessEval(currentNode.fen), 1000);
                return () => clearTimeout(lichessTimeoutRef.current);
            }, [currentNode, lichessEnabled, runLichessEval]);

            // --- AUTO EVAL UPDATE (Highest Depth Wins) ---
             useEffect(() => {
                if (!aiAutoEval || currentNode.eval !== null) return;
                
                const bestData = getBestEngineData();
                if (bestData) {
                    // Update only if this engine is deeper than what's saved on the node
                    // (Or if the node has no depth info yet)
                    const currentSavedDepth = currentNode.aiDepth || 0;
                    if (bestData.depth >= currentSavedDepth) {
                         currentNode.aiEval = bestData.val;
                         currentNode.aiDepth = bestData.depth;
                    }
                }
            }, [stockfishData, lichessData, aiAutoEval, currentNode, getBestEngineData]);

            // ... (Rest of Keyboard, Move Logic same as before)
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    if (promotionPending) return; 
                    switch(e.key) {
                        case 'ArrowLeft': if (currentNode.parent) setCurrentNode(currentNode.parent); break;
                        case 'ArrowRight': if (currentNode.children.length > 0) setCurrentNode(currentNode.children[0]); break;
                        case 'ArrowUp': setCurrentNode(rootNode); break;
                        case 'ArrowDown': { let temp = currentNode; while(temp.children.length > 0) temp = temp.children[0]; setCurrentNode(temp); break; }
                        case 'Delete': case 'Backspace': deleteCurrentNodeRef.current(); break;
                        case 'f': case 'F': setOrientation(prev => prev === 'white' ? 'black' : 'white'); break;
                        case 's': case 'S': saveCollectionRef.current(); break;
                        case 'a': case 'A': setShowAiArrow(prev => !prev); break;
                        default: break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentNode, rootNode, promotionPending]);

            const deleteCurrentNodeRef = useRef();
            const saveCollectionRef = useRef();

            useEffect(() => {
                const newGame = new Chess();
                const moves = []; let temp = currentNode; while(temp.parent) { moves.push(temp.san); temp = temp.parent; } moves.reverse();
                try { moves.forEach(m => newGame.move(m)); } catch(e) { newGame.load(currentNode.fen); }
                setGame(newGame);
                let status = null;
                const manualLink = "https://arbiters.fide.com/wp-content/uploads/Publications/Manual/Arbiters_Manual_2025.pdf";
                if (newGame.in_checkmate()) status = { title: `Checkmate! ${newGame.turn()==='w'?'Black':'White'} Wins`, sub: 'รุกฆาต', rule: 'Article 5.1.1', link: manualLink };
                else if (newGame.in_stalemate()) status = { title: 'Draw by Stalemate', sub: 'เสมอ (อับ)', rule: 'Article 5.2.1', link: manualLink };
                else if (newGame.insufficient_material()) status = { title: 'Draw - Insufficient Material', sub: 'เสมอ (หมากไม่พอ)', rule: 'Article 5.2.2', link: manualLink };
                else if (newGame.in_threefold_repetition()) status = { title: 'Draw - Threefold Repetition', sub: 'เสมอ (ตาเดินซ้ำ)', rule: 'Article 9.2', link: manualLink };
                else if (newGame.in_draw()) status = { title: 'Draw - 50-Move Rule', sub: 'เสมอ (กฎ 50 ตา)', rule: 'Article 9.3', link: manualLink };
                else if (newGame.in_check()) status = { title: 'Check!', sub: 'รุก!', rule: null };
                setGameStatus(status); setSelectedSquare(null); setPossibleMoves([]); setEvalValue(currentNode.eval); setCommentValue(currentNode.comment || "");
            }, [currentNode]);

            useEffect(() => {
                if (showHighlights && game) setMovablePieces([...new Set(game.moves({ verbose: true }).map(m => m.from))]);
                else setMovablePieces([]);
            }, [game, showHighlights]);

            const updateNodeData = (field, value) => {
                currentNode[field] = value;
                if(field === 'eval') setEvalValue(value);
                if(field === 'comment') setCommentValue(value);
            };

            // DISPLAY EVAL: Use manual, or Best Engine (Max Depth)
            const bestEngineData = getBestEngineData();
            const effectiveEval = evalValue !== null ? evalValue : (bestEngineData ? bestEngineData.val : 0.0);
            const isUsingAiEval = evalValue === null && bestEngineData;
            
            const showNotification = (msg) => { setNotification(msg); setTimeout(() => setNotification(null), 3000); };

            const executeMove = (from, to, promotion = 'q') => {
                try {
                    const tmp = new Chess();
                    const historyMoves = []; let ptr = currentNode; while(ptr.parent) { historyMoves.unshift(ptr.san); ptr = ptr.parent; }
                    historyMoves.forEach(m => tmp.move(m));
                    const move = tmp.move({ from: from, to: to, promotion: promotion });
                    if (move) {
                        const existing = currentNode.children.find(child => child.san === move.san);
                        if (existing) setCurrentNode(existing);
                        else {
                            const num = game.turn() === 'w' ? currentNode.moveNumber + 1 : currentNode.moveNumber;
                            const newNode = new MoveNode(move.san, tmp.fen(), currentNode, num, game.turn());
                            currentNode.children.push(newNode); setCurrentNode(newNode);
                        }
                        new Audio(move.captured ? 'https://images.chesscomfiles.com/chess-themes/sounds/_common/capture.mp3' : 'https://images.chesscomfiles.com/chess-themes/sounds/_common/move-self.mp3').play().catch(()=>{});
                    }
                } catch(e) {}
                setSelectedSquare(null); setPossibleMoves([]);
            };

            const handleSquareClick = (row, col) => {
                if (promotionPending) return;
                const r = orientation === 'white' ? row : 7 - row;
                const c = orientation === 'white' ? col : 7 - col;
                const sq = String.fromCharCode(97 + c) + (8 - r);
                if (selectedSquare === sq) { setSelectedSquare(null); setPossibleMoves([]); return; }
                if (selectedSquare) {
                    const verboseMoves = game.moves({ verbose: true });
                    const isPromotion = verboseMoves.some(m => m.from === selectedSquare && m.to === sq && m.promotion);
                    if (isPromotion) { setPromotionPending({ from: selectedSquare, to: sq }); return; }
                    if (possibleMoves.includes(sq)) { executeMove(selectedSquare, sq); return; }
                }
                const p = game.get(sq);
                if (p && p.color === game.turn()) { setSelectedSquare(sq); if(showHighlights) setPossibleMoves(game.moves({ square: sq, verbose: true }).map(m => m.to)); } 
                else { setSelectedSquare(null); setPossibleMoves([]); }
            };

            const handlePromotionSelect = (piece) => {
                if (promotionPending) { executeMove(promotionPending.from, promotionPending.to, piece); setPromotionPending(null); }
            };

            const deleteCurrentNode = () => { if (!currentNode.parent) return; if (confirm(`Delete ${currentNode.san}?`)) { const p = currentNode.parent; p.children = p.children.filter(c => c.id !== currentNode.id); setCurrentNode(p); }};
            deleteCurrentNodeRef.current = deleteCurrentNode;

            const saveCollection = () => { 
                let name = prompt("Enter Name:"); 
                if (!name) return; 
                let newName = name; let counter = 1;
                while (savedCollections.some(c => c.name === newName)) { newName = `${name} (${counter})`; counter++; }
                const updated = [...savedCollections, { id: Date.now(), name: newName, date: new Date().toLocaleDateString(), data: serializeNode(rootNode) }]; 
                setSavedCollections(updated); 
                localStorage.setItem('chess_book_collections', JSON.stringify(updated)); 
                showNotification(`Saved as "${newName}"`); 
            };
            saveCollectionRef.current = saveCollection;

            const loadCollection = (col) => { 
                if (confirm(`Load "${col.name}"?`)) { 
                    const newRoot = deserializeNode(col.data); rootNode.children = newRoot.children; 
                    const fix = (n, p) => { n.parent = p; n.children.forEach(c => fix(c, n)); }; fix(rootNode, null); 
                    setCurrentNode(rootNode); setActiveTab('notation'); setShowCollections(false);
                }
            };
            const deleteCollection = (id) => { if(confirm("Delete?")) { const updated = savedCollections.filter(c => c.id !== id); setSavedCollections(updated); localStorage.setItem('chess_book_collections', JSON.stringify(updated)); }};
            
            const importFile = (e) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const content = evt.target.result;
                    try {
                        if (content.includes("###CHESS_DATA_START###")) {
                            const parts = content.split("###CHESS_DATA_START###");
                            const rawJson = parts[1].split("###CHESS_DATA_END###")[0];
                            const parsed = JSON.parse(rawJson);
                            if (parsed.data) {
                                const dataToLoad = Array.isArray(parsed.data) ? parsed.data : [{ id: Date.now(), name: `Imported PDF ${new Date().toLocaleTimeString()}`, date: new Date().toLocaleDateString(), data: parsed.data }];
                                const merged = [...savedCollections, ...dataToLoad];
                                setSavedCollections(merged); localStorage.setItem('chess_book_collections', JSON.stringify(merged));
                                showNotification("Data extracted from PDF!");
                            }
                        } else {
                            const imported = JSON.parse(content);
                            if (Array.isArray(imported)) {
                                const merged = [...savedCollections, ...imported]; setSavedCollections(merged); localStorage.setItem('chess_book_collections', JSON.stringify(merged)); showNotification("Collections Imported!");
                            } else throw new Error("Invalid format");
                        }
                    } catch (err) { console.error(err); alert("Invalid File or No Embedded Data found."); }
                };
                reader.readAsText(file, "ISO-8859-1");
            };

            const exportCollections = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(savedCollections));
                const downloadAnchorNode = document.createElement('a'); downloadAnchorNode.setAttribute("href", dataStr); downloadAnchorNode.setAttribute("download", "chess_collections.json");
                document.body.appendChild(downloadAnchorNode); downloadAnchorNode.click(); downloadAnchorNode.remove(); showNotification("Collections Exported!");
            };

            const copyPGN = () => { navigator.clipboard.writeText(generateTreePGN(rootNode)).then(()=>showNotification("PGN Copied")); };
            
            const generatePDF = async () => {
                const meta = parseMetadata(rootNode.comment);
                setIsGenerating(true); showNotification("Generating Smart PDF...");
                const pdfImgs = await loadPieceImages();
                const { jsPDF } = window.jspdf; const doc = new jsPDF();
                
                doc.setProperties({ title: meta.title, author: meta.author, subject: "Chess Book Pro Smart Doc" });
                doc.setFont("helvetica", "bold"); doc.setFontSize(16); doc.text(meta.title, 105, 15, { align: "center" });
                
                const line = []; let temp = currentNode; while(temp.parent) { line.unshift(temp); temp = temp.parent; } 
                let future = currentNode; while(future.children.length > 0) { future = future.children[0]; line.push(future); }
                let x=25, y=25, col=0, row=0; const boxW=58, boardS=48, boxH=66;
                
                const drawBoard = (fen, label, node) => {
                    const board = getBoardFromFen(fen); const px = x + (boxW-boardS)/2;
                    doc.setFontSize(10); doc.setTextColor(0); doc.text(label, px+boardS/2, y+4, {align:"center"});
                    const by = y+6; doc.setLineWidth(0.05); doc.setDrawColor(0); const sq = boardS/8;
                    for(let r=0;r<8;r++){for(let c=0;c<8;c++){
                        if((r+c)%2===1){ doc.setFillColor(240); doc.rect(px+c*sq, by+r*sq, sq, sq, 'F'); }
                        doc.rect(px+c*sq, by+r*sq, sq, sq);
                        const p=board[r][c];
                        if(p){ const im=pdfImgs[p===p.toUpperCase()?'w':'b'][p.toLowerCase()]; if(im) doc.addImage(im, 'PNG', px+c*sq+0.5, by+r*sq+0.5, sq-1, sq-1); }
                    }}
                    const barY=by+boardS+1; doc.setDrawColor(150); doc.rect(px, barY, boardS, 2.5);
                    
                    // PDF EVAL LOGIC: Prefer manual > aiEval (which is now guaranteed to be max depth)
                    const useEval = node.eval !== null ? node.eval : (node.aiEval !== undefined ? node.aiEval : 0.0);
                    const val = Math.max(-5, Math.min(5, useEval)); 
                    const cw = px+(boardS/2); const fw = (Math.abs(val)/5)*(boardS/2);
                    doc.setFillColor(100); if(val>0) doc.rect(cw, barY, fw, 2.5, 'F'); else doc.rect(cw-fw, barY, fw, 2.5, 'F');
                    doc.setDrawColor(0); doc.line(cw, barY, cw, barY+2.5);
                    doc.setFontSize(8); doc.text(`${val>0?'+':''}${Number(val).toFixed(2)}`, px+boardS, barY+6.5, {align:"right"});
                    
                    const isRoot = node.san === 'Start';
                    const commText = isRoot ? "" : (node.comment || "");
                    const comm = doc.splitTextToSize(commText, boardS-10); doc.text(comm.length>2?comm.slice(0,2):comm, px, barY+6.5);
                };

                drawBoard(initialFen, "Start", rootNode); x+=boxW; col++;
                line.forEach((n,i)=>{ const lbl = n.turn==='w'?`${n.moveNumber}. ${n.san}`:`${n.moveNumber}... ${n.san}`; drawBoard(n.fen, lbl, n); x+=boxW; col++; if(col>=3){ col=0; x=25; y+=boxH; row++; if(row>=4 && i<line.length-1){doc.addPage(); y=25; row=0;} } });
                
                const serializedData = serializeNode(rootNode);
                const jsonStr = JSON.stringify(serializedData);
                const hash = await computeSHA256(jsonStr);
                const payload = { hash: hash, data: serializedData };
                const payloadStr = JSON.stringify(payload);
                const pdfBlob = doc.output('blob');
                const finalBlob = new Blob([pdfBlob, EMBED_START, payloadStr, EMBED_END], { type: 'application/pdf' });
                
                const filename = meta.filename.endsWith('.pdf') ? meta.filename : `${meta.filename}.pdf`;
                const url = URL.createObjectURL(finalBlob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                setIsGenerating(false);
            };

            const activeBestMoveUci = bestEngineData?.bestMoveUci;

            const renderAiArrow = () => {
                if (!showAiArrow || !activeBestMoveUci) return null;
                const uci = activeBestMoveUci;
                const from = uci.substring(0, 2);
                const to = uci.substring(2, 4);
                const fromFile = from.charCodeAt(0) - 97; 
                const fromRank = parseInt(from[1]) - 1;
                const toFile = to.charCodeAt(0) - 97; 
                const toRank = parseInt(to[1]) - 1;
                let x1, y1, x2, y2;
                if (orientation === 'white') { x1 = fromFile; y1 = 7 - fromRank; x2 = toFile; y2 = 7 - toRank; } 
                else { x1 = 7 - fromFile; y1 = fromRank; x2 = 7 - toFile; y2 = toRank; }
                const toPct = (v) => v * 12.5 + 6.25;
                const arrowColor = stockfishData ? "#a855f7" : "#3b82f6";

                return (
                    <svg className="absolute top-0 left-0 w-full h-full pointer-events-none z-20" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <defs><marker id="arrowhead-ai" markerWidth="3" markerHeight="3" refX="2" refY="1.5" orient="auto"><polygon points="0 0, 3 1.5, 0 3" fill={arrowColor} opacity="0.9"/></marker></defs>
                        <line x1={toPct(x1)} y1={toPct(y1)} x2={toPct(x2)} y2={toPct(y2)} stroke={arrowColor} strokeWidth="3" opacity="0.9" strokeLinecap="round" markerEnd="url(#arrowhead-ai)"/>
                        <circle cx={toPct(x1)} cy={toPct(y1)} r="1.5" fill={arrowColor} opacity="0.9" />
                    </svg>
                );
            };

            const renderBoard = () => {
                const b = getBoardFromFen(currentNode.fen);
                const sqs = [];
                for(let r=0;r<8;r++){ for(let c=0;c<8;c++){
                    const ar=orientation==='white'?r:7-r, ac=orientation==='white'?c:7-c;
                    const s=String.fromCharCode(97+ac)+(8-ar); const isLight=(ar+ac)%2===0; const p=b[ar][ac];
                    const isSel=selectedSquare===s; const isPoss=possibleMoves.includes(s); const isMov=movablePieces.includes(s);
                    sqs.push(<div key={`${r}-${c}`} onClick={()=>handleSquareClick(ar,ac)} className={`w-full h-full flex justify-center items-center relative cursor-pointer ${isLight?'bg-[#ebecd0]':'bg-[#739552]'} ${isSel?'!bg-[#f7f769]':''}`}>
                        {ac===(orientation==='white'?0:7) && <span className={`absolute top-0.5 left-0.5 text-[10px] font-bold ${isLight?'text-[#739552]':'text-[#ebecd0]'}`}>{8-ar}</span>}
                        {ar===(orientation==='white'?7:0) && <span className={`absolute bottom-0 right-1 text-[10px] font-bold ${isLight?'text-[#739552]':'text-[#ebecd0]'}`}>{String.fromCharCode(97+ac)}</span>}
                        {isMov && !isSel && <div className="absolute w-full h-full border-[3px] border-blue-400/70 rounded-lg z-0"></div>}
                        {isPoss && !p && <div className="w-[30%] h-[30%] rounded-full bg-[rgba(0,0,0,0.2)] z-10"></div>}
                        {isPoss && p && <div className="absolute w-full h-full border-[6px] border-[rgba(0,0,0,0.2)] rounded-full z-10"></div>}
                        {p && <img src={PIECE_IMAGES[p===p.toUpperCase()?'w':'b'][p.toLowerCase()]} className="w-[90%] h-[90%] z-10 relative select-none"/>}
                    </div>);
                }} 
                return <>{sqs}{renderAiArrow()}</>;
            };

            const activeLine = useMemo(() => {
                const line = []; let temp = currentNode; while(temp.parent) { line.unshift(temp); temp = temp.parent; }
                let future = currentNode; while(future.children.length > 0) { future = future.children[0]; line.push(future); }
                const pairs = []; let i = 0;
                while(i < line.length) {
                    const node = line[i];
                    const siblings = node.parent ? node.parent.children.filter(c => c.id !== node.id) : [];
                    if (node.turn === 'w') {
                        const pair = { num: node.moveNumber, white: node, whiteVars: siblings, black: null, blackVars: [] };
                        if (i+1 < line.length && line[i+1].turn === 'b') {
                            pair.black = line[i+1]; pair.blackVars = line[i+1].parent.children.filter(c => c.id !== line[i+1].id); i++;
                        }
                        pairs.push(pair);
                    } else { pairs.push({ num: node.moveNumber, white: null, whiteVars: [], black: node, blackVars: siblings }); }
                    i++;
                }
                return pairs;
            }, [currentNode]);

            const PromotionModal = () => {
                if (!promotionPending) return null;
                const turn = game.turn();
                const pieces = ['q', 'r', 'b', 'n'];
                return (
                    <div className="absolute inset-0 z-40 flex items-center justify-center bg-black/40 backdrop-blur-sm animate-fade-in" onClick={() => setPromotionPending(null)}>
                        <div className="bg-[#262421] p-4 rounded-xl border border-[#403d39] shadow-2xl transform scale-100 flex gap-2" onClick={e=>e.stopPropagation()}>
                           {pieces.map(p => (
                               <button key={p} onClick={() => handlePromotionSelect(p)} className="w-16 h-16 bg-[#302e2b] hover:bg-[#403d39] rounded-lg flex items-center justify-center border border-[#403d39] hover:border-green-500 transition-all">
                                   <img src={PIECE_IMAGES[turn][p]} className="w-12 h-12"/>
                               </button>
                           ))}
                        </div>
                    </div>
                );
            };

            const renderTools = () => (
                <div className="flex flex-col gap-4 h-full p-4 overflow-y-auto">
                    <div className="hidden lg:flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2 text-green-500 font-bold text-xl"><span>♟ Chess Book Pro</span></div>
                        <button onClick={()=>setShowShortcuts(true)} className="p-1.5 bg-[#302e2b] rounded text-gray-400 hover:text-white border border-[#403d39]" title="Keyboard Shortcuts"><Keyboard size={16}/></button>
                    </div>

                    <div className="bg-[#302e2b] p-3 rounded-lg flex flex-col gap-2">
                         <div className="flex justify-between gap-1">
                            <button onClick={()=>setCurrentNode(rootNode)} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronsLeft size={18}/></button>
                            <button onClick={()=>{if(currentNode.parent)setCurrentNode(currentNode.parent)}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronLeft size={18}/></button>
                            <button onClick={()=>{if(currentNode.children.length)setCurrentNode(currentNode.children[0])}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronRight size={18}/></button>
                            <button onClick={()=>{let t=currentNode;while(t.children.length)t=t.children[0];setCurrentNode(t)}} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47]"><ChevronsRight size={18}/></button>
                        </div>
                        <div className="flex justify-between gap-1 mt-1">
                            <button onClick={()=>setOrientation(o=>o==='white'?'black':'white')} className="flex-1 p-2 bg-[#403d39] rounded hover:bg-[#504c47] text-gray-300" title="Flip Board"><RotateCcw size={18}/></button>
                            <button onClick={()=>setShowHighlights(!showHighlights)} className={`flex-1 p-2 rounded hover:bg-[#504c47] ${showHighlights?'bg-green-600/50 text-green-200':'bg-[#403d39] text-gray-400'}`} title="Highlights">{showHighlights?<Eye size={18}/>:<EyeOff size={18}/>}</button>
                            <button onClick={()=>setShowAiArrow(!showAiArrow)} className={`flex-1 p-2 rounded hover:bg-[#504c47] ${showAiArrow?'bg-blue-600/50 text-blue-200':'bg-[#403d39] text-gray-400'}`} title="AI Arrow"><Navigation size={18}/></button>
                            <button onClick={deleteCurrentNode} className="flex-1 p-2 bg-[#403d39] text-red-400 rounded hover:bg-[#504c47]" title="Delete Move"><Scissors size={18}/></button>
                        </div>
                    </div>

                    <div className="bg-[#302e2b] p-3 rounded-lg flex gap-3 min-h-[180px]">
                        <div className="w-12 flex flex-col items-center gap-2 h-full relative">
                            <span className="text-[10px] text-gray-400">EVAL</span>
                            <div className="relative w-full">
                                <input type="number" step="0.1" value={evalValue !== null ? evalValue : ''} placeholder={isUsingAiEval ? "AI" : ""} onChange={(e)=>updateNodeData('eval', e.target.value === '' ? null : parseFloat(e.target.value))} className={`w-full bg-[#211f1c] text-center text-xs rounded border border-[#403d39] py-1 ${isUsingAiEval ? 'text-purple-400 border-purple-500/50' : ''}`}/>
                                {evalValue !== null && <button onClick={() => updateNodeData('eval', null)} className="absolute -right-5 top-0.5 bg-[#403d39] text-[8px] text-gray-300 px-1 rounded hover:bg-gray-600">AI</button>}
                            </div>
                            <div className="flex-1 w-full flex justify-center py-1"><input type="range" min="-5" max="5" step="0.1" value={evalValue !== null ? evalValue : 0} onChange={(e)=>updateNodeData('eval',parseFloat(e.target.value))} className="vertical"/></div>
                            <span className={`text-xs font-mono font-bold ${effectiveEval>0?'text-green-400':effectiveEval<0?'text-red-400':'text-gray-400'}`}>{effectiveEval>0?'+':''}{Number(effectiveEval).toFixed(1)}</span>
                        </div>
                        <div className="flex-1 flex flex-col gap-2">
                            <div className="text-[10px] text-gray-400 flex items-center gap-1"><MessageSquare size={12}/> {currentNode.san === 'Start' ? "METADATA" : "COMMENT"}</div>
                            <textarea value={commentValue} onChange={(e)=>updateNodeData('comment',e.target.value)} placeholder={currentNode.san === 'Start' ? "Title: My Game..." : "Notes..."} className="w-full h-full bg-[#211f1c] border border-[#403d39] rounded p-2 text-sm text-gray-200 resize-none outline-none focus:border-green-500"/>
                        </div>
                    </div>

                    <div className="flex gap-2">
                        <button onClick={copyPGN} className="flex-1 py-2 bg-[#302e2b] rounded text-sm font-bold text-gray-300 flex justify-center gap-2 hover:bg-[#403d39]"><Share size={16}/> PGN</button>
                        <button onClick={generatePDF} className="flex-1 py-2 bg-green-600 rounded text-sm font-bold text-white flex justify-center gap-2 shadow hover:bg-green-500"><Download size={16}/> PDF</button>
                    </div>
                    <button onClick={()=>setShowCollections(true)} className="w-full py-2 bg-[#403d39] rounded text-sm font-bold text-blue-300 flex justify-center gap-2 border border-blue-500/30 hover:bg-[#504c47] hover:border-blue-500"><Folder size={16}/> Collections</button>
                </div>
            );

            const renderNotation = () => (
                <div className="flex flex-col h-full overflow-hidden">
                   <div className="overflow-y-auto flex-1 p-2">
                        {activeLine.map((pair, i) => (
                            <div key={i}>
                                <div className="main-row">
                                    <div className="main-num">{pair.num}.</div>
                                    {pair.white ? <div className={`main-cell ${pair.white.id===currentNode.id?'active-move':'text-gray-300'}`} onClick={()=>setCurrentNode(pair.white)}>{pair.white.san}</div> : <div className="main-cell text-gray-600">...</div>}
                                    {pair.black ? <div className={`main-cell ${pair.black.id===currentNode.id?'active-move':'text-gray-300'}`} onClick={()=>setCurrentNode(pair.black)}>{pair.black.san}</div> : <div className="main-cell"></div>}
                                </div>
                                {pair.whiteVars.map(v=><div key={v.id} className="var-block"><span className="var-text" onClick={()=>setCurrentNode(v)}>({getFullVariationText(v)})</span></div>)}
                                {pair.blackVars.map(v=><div key={v.id} className="var-block"><span className="var-text" onClick={()=>setCurrentNode(v)}>({getFullVariationText(v)})</span></div>)}
                            </div>
                        ))}
                    </div>
                </div>
            );

            const renderAI = () => (
                <div className="p-4 flex flex-col h-full gap-4 overflow-y-auto">
                    <div className="flex justify-between items-center mb-2">
                        <span className="text-sm font-bold text-gray-200 flex items-center gap-2"><Brain size={16}/> Engines</span>
                        <div className="flex items-center gap-2">
                            <span className="text-[10px] text-gray-400">Auto</span>
                            <div className="relative inline-block w-6 align-middle select-none transition duration-200 ease-in">
                                <input type="checkbox" checked={aiAutoEval} onChange={()=>setAiAutoEval(!aiAutoEval)} className="toggle-checkbox absolute block w-3 h-3 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                                <label className={`toggle-label block overflow-hidden h-3 rounded-full cursor-pointer ${aiAutoEval ? 'bg-green-500' : 'bg-gray-600'}`}></label>
                            </div>
                        </div>
                    </div>

                    <AiDisplayPanel title="Stockfish 10 (Local)" subTitle="Offline" icon={Cpu} enabled={stockfishEnabled} onToggle={()=>setStockfishEnabled(!stockfishEnabled)} data={stockfishData} loading={stockfishEnabled && !stockfishData} color="purple">
                        <div className="mb-2">
                            <div className="flex justify-between text-[10px] text-gray-400 mb-1"><span>Depth</span><span className="text-purple-300 font-bold">{aiDepth}</span></div>
                            <input type="range" min="10" max="50" step="1" value={aiDepth} onChange={(e)=>setAiDepth(parseInt(e.target.value))} className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer"/>
                            <div className="flex justify-between text-[9px] text-gray-500 mt-1"><span>Fast (10)</span><span>Max (50)</span></div>
                        </div>
                    </AiDisplayPanel>

                    <AiDisplayPanel title="Lichess Cloud" subTitle="Online" icon={Globe} enabled={lichessEnabled} onToggle={()=>setLichessEnabled(!lichessEnabled)} data={lichessData} loading={isLichessLoading} color="blue"/>
                    {!stockfishEnabled && !lichessEnabled && <div className="text-center text-gray-500 text-xs mt-4">Enable an engine above.</div>}
                </div>
            );

            return (
                <div className="flex flex-col lg:flex-row w-screen h-screen bg-[#262421]">
                    {showShortcuts && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={()=>setShowShortcuts(false)}>
                            <div className="bg-[#302e2b] p-6 rounded-xl border border-[#403d39] w-[400px] shadow-2xl" onClick={e=>e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4 border-b border-[#403d39] pb-2">
                                    <h3 className="text-lg font-bold text-green-500 flex items-center gap-2"><Keyboard size={20}/> Shortcuts</h3>
                                    <button onClick={()=>setShowShortcuts(false)} className="text-gray-400 hover:text-white"><Close size={20}/></button>
                                </div>
                                <div className="space-y-3 text-sm text-gray-300">
                                    <div className="flex justify-between"><span>Next/Prev</span> <span>← / →</span></div>
                                    <div className="flex justify-between"><span>Start/End</span> <span>↑ / ↓</span></div>
                                </div>
                            </div>
                        </div>
                    )}

                    {showCollections && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm" onClick={()=>setShowCollections(false)}>
                            <div className="bg-[#211f1c] p-0 rounded-xl border border-[#403d39] w-[90vw] md:w-[500px] shadow-2xl flex flex-col max-h-[80vh]" onClick={e=>e.stopPropagation()}>
                                <div className="p-4 border-b border-[#302e2b] flex justify-between items-center bg-[#2a2825] rounded-t-xl">
                                    <h3 className="text-lg font-bold text-gray-200 flex items-center gap-2"><Folder size={18}/> Collections</h3>
                                    <button onClick={()=>setShowCollections(false)} className="text-gray-400 hover:text-white"><Close size={20}/></button>
                                </div>
                                <div className="p-4 flex gap-2 border-b border-[#302e2b] bg-[#302e2b]">
                                    <button onClick={saveCollection} className="flex-1 py-2 bg-blue-600 hover:bg-blue-500 rounded text-sm text-white font-bold flex items-center justify-center gap-1 shadow"><Save size={14}/> Save</button>
                                    <button onClick={exportCollections} className="flex-1 py-2 bg-[#403d39] hover:bg-[#504c47] rounded text-sm text-gray-200 font-bold flex items-center justify-center gap-1"><Download size={14}/> Export</button>
                                    <label className="flex-1 py-2 bg-[#403d39] hover:bg-[#504c47] rounded text-sm text-gray-200 font-bold flex items-center justify-center gap-1 cursor-pointer"><Upload size={14}/> Import<input type="file" accept=".json,.pdf" className="hidden" onChange={importFile} /></label>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2 bg-[#211f1c]">
                                    {savedCollections.map(col => (
                                        <div key={col.id} className="bg-[#302e2b] p-3 rounded border border-[#403d39] flex justify-between items-center hover:border-green-500/30 transition">
                                            <div className="flex-1 min-w-0 mr-4">
                                                <div className="text-sm font-bold text-gray-200 truncate">{col.name}</div>
                                                <div className="text-[10px] text-gray-500">{col.date}</div>
                                            </div>
                                            <div className="flex gap-2">
                                                <button onClick={()=>loadCollection(col)} className="px-3 py-1 bg-green-700 hover:bg-green-600 text-white text-xs rounded font-bold">Load</button>
                                                <button onClick={()=>deleteCollection(col.id)} className="p-1.5 text-red-400 hover:bg-red-900/20 rounded"><Trash size={14}/></button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="hidden lg:flex w-[300px] bg-[#211f1c] border-r border-[#302e2b] flex-col z-20 shadow-xl">
                        {renderTools()}
                    </div>

                    <div className="flex-1 flex flex-col items-center bg-[#302e2b] relative overflow-hidden">
                        <div className="lg:hidden w-full bg-[#211f1c] p-2 flex justify-between items-center border-b border-[#302e2b]">
                            <span className="text-green-500 font-bold text-lg">♟ Chess Book</span>
                            <button onClick={()=>setShowShortcuts(true)} className="p-1 text-gray-400"><Keyboard size={20}/></button>
                        </div>

                        {notification && <div className="absolute top-14 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded shadow-lg z-50 text-sm animate-fade-in">{notification}</div>}
                        {gameStatus && (
                            <div className="absolute top-16 left-1/2 transform -translate-x-1/2 px-6 py-3 rounded-xl shadow-2xl z-30 bg-gray-800/95 text-white border border-gray-600 backdrop-blur-sm text-center">
                                <div className="font-bold text-lg mb-1 text-green-400">{gameStatus.title}</div>
                                {gameStatus.sub && <div className="text-sm text-gray-300 mb-1">{gameStatus.sub}</div>}
                            </div>
                        )}

                        <div className="w-full flex-1 flex flex-col justify-center items-center p-2 lg:p-4">
                             <div className="w-full max-w-[600px] aspect-square shadow-2xl border-[4px] lg:border-[8px] border-[#211f1c] grid grid-cols-8 grid-rows-8 relative">
                                {renderBoard()}
                                <PromotionModal />
                            </div>
                            
                            <div className="lg:hidden w-full max-w-[600px] flex justify-between gap-1 mt-2">
                                <button onClick={()=>{if(currentNode.parent)setCurrentNode(currentNode.parent)}} className="flex-1 p-3 bg-[#403d39] rounded text-white flex justify-center"><ChevronLeft size={24}/></button>
                                <button onClick={()=>{if(currentNode.children.length)setCurrentNode(currentNode.children[0])}} className="flex-1 p-3 bg-[#403d39] rounded text-white flex justify-center"><ChevronRight size={24}/></button>
                            </div>
                        </div>
                    </div>

                    <div className="hidden lg:flex w-[300px] bg-[#211f1c] border-l border-[#302e2b] flex-col relative">
                        <div className="flex border-b border-[#302e2b]">
                            <button onClick={()=>setActiveTab('notation')} className={`flex-1 p-3 text-xs font-bold ${activeTab==='notation'?'text-green-500 border-b-2 border-green-500':'text-gray-400 hover:bg-[#302e2b]'}`}>Notation</button>
                            <button onClick={()=>setActiveTab('ai')} className={`flex-1 p-3 text-xs font-bold ${activeTab==='ai'?'text-purple-500 border-b-2 border-purple-500':'text-gray-400 hover:bg-[#302e2b]'}`}>AI</button>
                        </div>
                        <div className="flex-1 overflow-y-auto">
                            {activeTab === 'notation' ? renderNotation() : renderAI()}
                        </div>
                    </div>

                    <div className="lg:hidden h-[35vh] bg-[#211f1c] border-t border-[#302e2b] flex flex-col">
                        <div className="flex border-b border-[#302e2b] bg-[#2a2825]">
                            <button onClick={()=>setMobileTab('tools')} className={`flex-1 py-3 text-xs font-bold flex justify-center items-center gap-2 ${mobileTab==='tools'?'mobile-tab-active':'mobile-tab-inactive'}`}><Wrench size={14}/> Tools</button>
                            <button onClick={()=>setMobileTab('notation')} className={`flex-1 py-3 text-xs font-bold flex justify-center items-center gap-2 ${mobileTab==='notation'?'mobile-tab-active':'mobile-tab-inactive'}`}><FileText size={14}/> Notation</button>
                            <button onClick={()=>setMobileTab('ai')} className={`flex-1 py-3 text-xs font-bold flex justify-center items-center gap-2 ${mobileTab==='ai'?'mobile-tab-active':'mobile-tab-inactive'}`}><Brain size={14}/> AI</button>
                        </div>
                        <div className="flex-1 overflow-hidden relative">
                            {mobileTab === 'tools' && renderTools()}
                            {mobileTab === 'notation' && renderNotation()}
                            {mobileTab === 'ai' && renderAI()}
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>